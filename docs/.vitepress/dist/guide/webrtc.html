<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>WebRTC для всех и каждого | Шпаргалки по IT</title>
    <meta name="description" content="Руководство по WebRTC для начинающих">
    <meta name="generator" content="VitePress v2.0.0-alpha.4">
    <link rel="preload stylesheet" href="/vitepress/assets/style.BxQII4rC.css" as="style">
    <link rel="preload stylesheet" href="/vitepress/vp-icons.css" as="style">
    
    <script type="module" src="/vitepress/assets/app.YXwjRglp.js"></script>
    <link rel="preload" href="/vitepress/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/vitepress/assets/chunks/theme.Ym8Cbd4G.js">
    <link rel="modulepreload" href="/vitepress/assets/chunks/framework.iqi_rrVU.js">
    <link rel="modulepreload" href="/vitepress/assets/guide_webrtc.md.Cbn-xxww.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/vitepress/" data-v-1168a8e4><!--[--><!--]--><!----><span data-v-1168a8e4>Шпаргалки по IT</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress/markdown-examples.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Шпаргалки</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress/links.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Ссылки</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress/other/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Разное</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress/guide/guide.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Руководства</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/AlexeyZelenko/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/AlexeyZelenko/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-8a42e2b4><button data-v-8a42e2b4>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 collapsible collapsed" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>База JS</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><section class="VPSidebarItem level-1 collapsible collapsed" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h3 class="text" data-v-b3fd67f8>Массивы</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/array_methods.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Методы массивов</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/arrays.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Массивы</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible collapsed" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h3 class="text" data-v-b3fd67f8>Объекты</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/object_methods.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Методы объектов</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/objects.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Объекты</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible collapsed" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h3 class="text" data-v-b3fd67f8>Асинхронное программирование</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/async.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>База</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/promises.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Промисы</p><!--]--></a><!----></div><!----></div><!--]--></div></section><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/event_loop.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Event Loop</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/design_patterns.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Design patterns</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/design_principles.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Design principles</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/dom.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Dom</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/events.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Events</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/functions.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Functions</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/map.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Map</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/set.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Set</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/modules.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Modules</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/numbers.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Numbers</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/strings.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Strings</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/questions_1.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Часто задаваемые вопросы</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/solid.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Основные принципы ООП</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_js/WCAG.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>WCAG</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 collapsible collapsed" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>База Vue</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/components.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Components</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/composables.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Composables</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/composition-api.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Composition Api</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/lifecycle_hooks.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Lifecycle Hooks</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/reactivity.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Реактивность</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/script-setup.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Script Setup</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/suspense.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Suspense</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/defineModel.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>defineModel</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/templateRefs.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Template Refs</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/basics_vue/watchEffect.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Watch Effect</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0" data-v-c40bc020 data-v-b3fd67f8><!----><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/guide/guide.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Руководства</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/other/" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Разное</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepress/links/" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Ссылки</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-ee010771><!--[--><!--]--><div class="container" data-v-ee010771><div class="aside" data-v-ee010771><div class="aside-curtain" data-v-ee010771></div><div class="aside-container" data-v-ee010771><div class="aside-content" data-v-ee010771><div class="VPDocAside" data-v-ee010771 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>On this page</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-ee010771><div class="content-container" data-v-ee010771><!--[--><!--]--><main class="main" data-v-ee010771><div style="position:relative;" class="vp-doc _vitepress_guide_webrtc" data-v-ee010771><div><h1 id="webrtc" tabindex="-1">WebRTC <a class="header-anchor" href="#webrtc" aria-label="Permalink to “WebRTC”">​</a></h1><blockquote><p><a href="https://webrtcforthecurious.com/" target="_blank" rel="noreferrer">Источник</a>.</p></blockquote><h2 id="что-такое-webrtc" tabindex="-1">Что такое WebRTC? <a class="header-anchor" href="#что-такое-webrtc" aria-label="Permalink to “Что такое WebRTC?”">​</a></h2><p><code>WebRTC</code> (Web Real-Time Communication - коммуникация в режиме реального времени) - это <a href="https://ru.wikipedia.org/wiki/API" target="_blank" rel="noreferrer">API</a> (Application Programming Interface - программный интерфейс приложения) и <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85" target="_blank" rel="noreferrer">протокол</a>. Протокол <code>WebRTC</code> - это набор правил, позволяющий двум агентам <code>WebRTC</code> (<a href="https://ru.wikipedia.org/wiki/%D0%91%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80" target="_blank" rel="noreferrer">браузерам</a>) вести двунаправленную (bi-directional) безопасную коммуникацию в реальном времени. <code>WebRTC API</code> позволяет разработчикам использовать протокол <code>WebRTC</code>. <code>WebRTC API</code> в настоящее время определен только для <code>JavaScript</code>.</p><p>Возможно, вам уже известна другая пара с похожим взаимодействием <a href="https://developer.mozilla.org/ru/docs/Web/HTTP" target="_blank" rel="noreferrer">HTTP</a> и <a href="https://developer.mozilla.org/ru/docs/Web/API/Fetch_API" target="_blank" rel="noreferrer">Fetch API</a>. В нашем случае протокол <code>WebRTC</code> - это <code>HTTP</code>, а <code>WebRTC API</code> - это <code>Fetch API</code>.</p><p>Протокол <code>WebRTC</code> поддерживается рабочей группой <a href="https://datatracker.ietf.org/wg/rtcweb/documents/" target="_blank" rel="noreferrer">rtcweb</a> <a href="https://www.ietf.org/" target="_blank" rel="noreferrer">IETF</a>. <code>WebRTC API</code> задокументирован в <a href="https://www.w3.org/" target="_blank" rel="noreferrer">W3C</a> как <a href="https://www.w3.org/TR/webrtc/" target="_blank" rel="noreferrer">webrtc</a>.</p><h3 id="зачем-изучать-webrtc" tabindex="-1">Зачем изучать WebRTC? <a class="header-anchor" href="#зачем-изучать-webrtc" aria-label="Permalink to “Зачем изучать WebRTC?”">​</a></h3><p>Если попытаться кратко описать особенности <code>WebRTC</code>, получится вот такой список. Притом он не является исчерпывающим, это просто примеры интересных характеристик, с которыми вы встретитесь, изучая <code>WebRTC</code>. Не волнуйтесь, если не знакомы с какими-то терминами, все они будут раскрыты далее:</p><ul><li>Открытый стандарт</li><li>Разные реализации</li><li>Доступность в браузерах</li><li>Обязательное шифрование</li><li>Отображение NAT (NAT Traversal)</li><li>Перепрофилирование существующих технологий</li><li>Контроль перегрузки (congestion control)</li><li>Низкая задержка (на уровне долей секунды, sub-second latency)</li></ul><h3 id="протокол-webrtc-это-собрание-других-технологии" tabindex="-1">Протокол WebRTC - это собрание других технологий <a class="header-anchor" href="#протокол-webrtc-это-собрание-других-технологии" aria-label="Permalink to “Протокол WebRTC - это собрание других технологий”">​</a></h3><p>В процессе установки соединения с помощью <code>WebRTC</code> можно выделить 4 этапа:</p><ul><li>Сигнализация (signalling)</li><li>Подключение (установка соединения) (connection)</li><li>Безопасность (securing)</li><li>Коммуникация (взаимодействие) (communication)</li></ul><p>Переходы между этапами происходят последовательно. Обязательным условием для начала следующего этапа является успешное завершение предыдущего.</p><p>Интересный факт о <code>WebRTC</code> - каждый этап состоит из большого количества других протоколов. Для создания <code>WebRTC</code> было объединено множество существующих технологий. В этом смысле <code>WebRTC</code> - это комбинация и конфигурация хорошо известных технологий, появившихся в начале 2000-х годов.</p><p>Каждому из перечисленных 4 этапов посвящен отдельный раздел, но для начала давайте рассмотрим их на самом высоком уровне. Поскольку этапы зависят друг от друга, в дальнейшем это облегчит объяснение и понимание назначения каждого из них.</p><h4 id="сигнализация-как-пиры-peers-находят-друг-друга" tabindex="-1">Сигнализация: как <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%BD%D0%BE%D1%80%D0%B0%D0%BD%D0%B3%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C" target="_blank" rel="noreferrer">пиры</a> (peers) находят друг друга <a class="header-anchor" href="#сигнализация-как-пиры-peers-находят-друг-друга" aria-label="Permalink to “Сигнализация: как пиры (peers) находят друг друга”">​</a></h4><p>При запуске <code>WebRTC</code> агент не знает, с кем и по поводу чего будет происходит коммуникация. И именно сигнализация дает нам прозрачность. Это первый этап и его назначение – подготовка вызова (звонка) (call) для того, чтобы два агента <code>WebRTC</code> могли начать коммуникацию.</p><p>Сигнализация осуществляется с помощью существующего протокола <a href="https://ru.wikipedia.org/wiki/Session_Description_Protocol" target="_blank" rel="noreferrer"><code>SDP</code></a> (Session Description Protocol - протокол описания сессии). Напомним, что <code>SDP</code> – это текстовый протокол. Каждое сообщение <code>SDP</code> состоит из нескольких пар ключ/значение и содержит список &quot;медиа разделов&quot; (media sections). <code>SDP</code>, которыми обмениваются агенты <code>WebRTC</code>, содержит следующую информацию: -<a href="https://ru.wikipedia.org/wiki/IP-%D0%B0%D0%B4%D1%80%D0%B5%D1%81" target="_blank" rel="noreferrer">IP</a> и порты, по которым можно получить доступ к агенту (candidates - кандидаты);</p><ul><li>какое количество аудио и видео треков хочет отправить агент;</li><li>какие аудио и видео кодеки поддерживаются каждым агентом;</li><li>значения, используемые в процессе подключения (<code>uFrag/uPwd</code>);</li><li>значения, используемые для обеспечения безопасности (certificate fingerprint - отпечаток сертификата).</li></ul><p><em>Обратите внимание</em>, что сигнализация, как правило, происходит вне <code>WebRTC</code>; <code>WebRTC</code>, обычно, не используется для передачи сигнальных сообщений (signalling messages). Для передачи <code>SDP</code> между подключенными пирами могут использоваться такие технологии, как конечные точки <a href="https://ru.wikipedia.org/wiki/REST" target="_blank" rel="noreferrer">REST</a>, <a href="https://ru.wikipedia.org/wiki/WebSocket" target="_blank" rel="noreferrer">веб-сокеты</a> или прокси аутентификации (authentication proxies).</p><h4 id="подключение-и-отображение-nat-с-помощью-stun-turn" tabindex="-1">Подключение и отображение NAT с помощью STUN/TURN <a class="header-anchor" href="#подключение-и-отображение-nat-с-помощью-stun-turn" aria-label="Permalink to “Подключение и отображение NAT с помощью STUN/TURN”">​</a></h4><p>В процессе сигнализации агенты <code>WebRTC</code> получают достаточно информации для того, чтобы попытаться выполнить подключение. Для этого используется другая технология под названием <code>ICE</code>.</p><p><code>ICE</code> (Interactive Connectivity Establishment - установка интерактивного соединения) - это еще один протокол, предшествующий появлению <code>WebRTC</code>. <code>ICE</code> позволяет устанавливать соединение между двумя агентами. Агенты могут находиться в одной (локальной) сети или в разных концах света. <code>ICE</code> - это решение для установки прямого соединения без центрального сервера.</p><p>Настоящее волшебство - это &quot;отображение NAT&quot; и серверы <code>STUN/TURN</code>. И это все, что вам нужно для коммуникации с агентом <code>ICE</code>, находящимся в другой подсети (subnet).</p><p>После успешного подключения <code>ICE</code> <code>WebRTC</code> приступает к установке зашифрованного транспортного канала. Он используется для передачи аудио, видео и других данных.</p><h4 id="обеспечение-безопасности-канала-передачи-данных-с-помощью-dtls-и-srtp" tabindex="-1">Обеспечение безопасности канала передачи данных с помощью DTLS и SRTP <a class="header-anchor" href="#обеспечение-безопасности-канала-передачи-данных-с-помощью-dtls-и-srtp" aria-label="Permalink to “Обеспечение безопасности канала передачи данных с помощью DTLS и SRTP”">​</a></h4><p>После того, как мы установили двунаправленный канал коммуникации (с помощью <code>ICE</code>), нам необходимо сделать этот канал безопасным. Это делается с помощью двух протоколов, также разработанных задолго до появления <code>WebRTC</code>. Первый протокол - это <a href="https://ru.wikipedia.org/wiki/DTLS" target="_blank" rel="noreferrer"><code>DTLS</code></a> (Datagram Transport Layer Security - протокол <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D1%82%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0" target="_blank" rel="noreferrer">датаграмм</a> безопасности транспортного уровня), который является просто <a href="https://ru.wikipedia.org/wiki/TLS" target="_blank" rel="noreferrer"><code>TLS</code></a> поверх <a href="https://ru.wikipedia.org/wiki/UDP" target="_blank" rel="noreferrer"><code>UDP</code></a>. <code>TLS</code> - это криптографический протокол, который используется для безопасной коммуникации через <a href="https://ru.wikipedia.org/wiki/HTTPS" target="_blank" rel="noreferrer"><code>HTTPS</code></a>. Второй протокол - это <a href="https://ru.wikipedia.org/wiki/SRTP" target="_blank" rel="noreferrer"><code>SRTP</code></a> (Secure Real-time Transport Protocol - используется для безопасной передачи данных в реальном времени).</p><p>Сначала <code>WebRTC</code> выполняет <a href="https://en.wikipedia.org/wiki/Handshaking" target="_blank" rel="noreferrer">рукопожатие</a> (handshake) <code>DTLS</code> с помощью соединения <code>ICE</code>. В отличие от <code>HTTPS</code>, <code>WebRTC</code> не использует центральный орган (central authority) для проверки сертификатов. Вместо этого <code>WebRTC</code> проверяет, что сертификат, переданный через <code>DTLS</code>, совпадает с отпечатком (fingerprint, мы подробно поговорим об этом в разделе, посвященном безопасности), переданным в процессе сигнализации. В дальнейшем <code>DTLS-подключение</code> используется для передачи сообщений по <code>DataChannel</code> (каналу передачи данных).</p><p>Для передачи аудио/видео используется другой протокол под названием <a href="https://ru.wikipedia.org/wiki/Real-time_Transport_Protocol" target="_blank" rel="noreferrer"><code>RTP</code></a> (Real-time Transport Protocol - протокол передачи данных в реальном времени). Пакеты, передаваемые по <code>RTP</code>, защищаются с помощью <code>SRTP</code>. Сессия <code>SRTP</code> начинается с извлечения ключей из установленной сессии <code>DTLS</code>.</p><p>Поздравляем! Если предыдущие этапы завершились успешно, у нас имеется двунаправленная и безопасная коммуникация. Если соединение между агентами <code>WebRTC</code> является стабильным, можно приступать к обмену данными. К сожалению, в реальном мире мы постоянно сталкиваемся с потерей пакетов и ограниченной пропускной способностью, о чем мы поговорим в следующем разделе.</p><h4 id="коммуникация-между-пирами-через-rtp-и-sctp" tabindex="-1">Коммуникация между пирами через RTP и SCTP <a class="header-anchor" href="#коммуникация-между-пирами-через-rtp-и-sctp" aria-label="Permalink to “Коммуникация между пирами через RTP и SCTP”">​</a></h4><p>Итак, мы установили безопасное двунаправленное соединение между двумя агентами <code>WebRTC</code> и наконец-то приступаем к коммуникации! Для этого используется два протокола: <code>RTP</code> и <a href="https://ru.wikipedia.org/wiki/SCTP" target="_blank" rel="noreferrer">SCTP</a> (Stream Control Transmission Protocol — протокол передачи с управлением потоком). <code>RTP</code> используется для передачи медиа, зашифрованного с помощью <code>SRTP</code>, а <code>SCTP</code> - нужен для отправки и приема сообщений по <code>DataChannel</code>, зашифрованных с помощью <code>DTLS</code>.</p><p><code>RTP</code> является довольно минималистичным, но он предоставляет все необходимое для потоковой передачи данных в реальном времени. Гибкость <code>RTP</code> позволяет разработчикам решать проблемы, связанные с задержкой, потерей данных и перегрузкой, самыми разнообразными способами.</p><p>Последним протоколом в стеке является <code>SCTP</code>. Он предоставляет множество настроек, связанных с доставкой сообщений. Мы, например, можем пожертвовать надежностью и правильным порядком доставки пакетов данных в пользу низкой задержки доставки. Именно она является критически важной для коммуникации в реальном времени.</p><h3 id="webrtc-коллекция-протоколов" tabindex="-1">WebRTC - коллекция протоколов <a class="header-anchor" href="#webrtc-коллекция-протоколов" aria-label="Permalink to “WebRTC - коллекция протоколов”">​</a></h3><p>На первый взгляд <code>WebRTC</code> может показаться перепроектированным (over-engineered). Но мы можем ему это простить, так как с его помощью мы можем решать большое количество проблем. Гениальность <code>WebRTC</code> заключается в его скромности: он не пытается решать все задачи самостоятельно. Вместо этого, он объединяет множество существующих специализированных технологий в единое целое.</p><p>Это позволяет исследовать и изучать каждую часть по-отдельности. Очень подходящее сравнение <code>WebRTC</code> – это оркестратор (orchestrator) большого количества других протоколов.</p><img src="https://habrastorage.org/webt/sq/lx/_w/sqlx_wxrgq97tnxjm8absyrmijk.png" alt=""><br><h3 id="как-работает-webrtc-api" tabindex="-1">Как работает WebRTC (API)? <a class="header-anchor" href="#как-работает-webrtc-api" aria-label="Permalink to “Как работает WebRTC (API)?”">​</a></h3><p>В этом разделе мы поговорим о том, как протокол <code>WebRTC</code> реализован в <code>JavaScript API</code>. Это не подробный обзор, а всего лишь попытка нарисовать общую картину того, что происходит в процессе коммуникации в реальном времени.</p><p><strong>new RTCPeerConnection</strong></p><p><code>RTCPeerConnection</code> - &quot;WebRTC-сессия&quot; верхнего уровня. Она объединяет все упомянутые выше протоколы. Выполняется подготовка всех необходимых подсистем, но пока еще ничего не происходит.</p><p><strong>addTrack</strong></p><p><code>addTrack</code> создает новый поток данных (stream) <code>RTP</code>. Для этого потока генерируется случайный источник синхронизации (Synchronization Source, <code>SSRC</code>). Поток находится внутри описания сессии (Session Description, <code>SDP</code>) (в медиаразделе), генерируемого <code>createOffer</code>. Каждый вызов <code>addTrack</code> создает новый <code>SSRC</code> и медиараздел.</p><p>После установки <code>SRTP-сессии</code> и шифрования, эти медиапакеты начинают передаваться через <code>ICE</code>.</p><p><strong>createDataChannel</strong></p><p><code>createDataChannel</code> создает новый <code>SCTP-поток</code> при его отсутствии. По умолчанию <code>SCTP</code> отключен, он включается только при запросе любой стороной канала передачи данных.</p><p>После установки <code>DTLS-сессии</code> и шифрования, эти пакеты с данными начинают передаваться через <code>ICE</code>.</p><p><strong>createOffer</strong></p><p><code>createOffer</code> генерирует описание локального состояния (local state) сессии, передаваемого удаленному (в значении &quot;находящемуся далеко&quot;, remote) пиру.</p><p>Вызов <code>createOffer</code> ничего не меняет для локального пира.</p><p><strong>setLocalDescription</strong></p><p><code>setLocalDescription</code> фиксирует (commits) запрошенные (произведенные) изменения. <code>addTrack</code>, <code>createDataChannel</code> и аналогичные вызовы являются временными до вызова <code>setLocalDescription</code>. <code>setLocalDescription</code> вызывается со значением, сгенерированным <code>createOffer</code>.</p><p><strong>setRemoteDescription</strong></p><p><code>setRemoteDescription</code> – способ информирования локального агента о состоянии удаленных кандидатов. Это сигнализация, выполняемая <code>JavaScript API</code>.</p><p>После вызова <code>setRemoteDescription</code> обеими сторонами, агенты <code>WebRTC</code> имеют достаточно информации для начала коммуникации <code>P2P</code> (Peer-To-Peer - равный к равному).</p><p><strong>addIceCandidate</strong></p><p><code>addIceCandidate</code> позволяет <code>WebRTC-агенту</code> добавлять дополнительных кандидатов <code>ICE</code> в любое время. Данный интерфейс отправляет кандидата <code>ICE</code> прямо в подсистему <code>ICE</code> и не оказывает никакого другого влияния на общее соединение.</p><p><strong>ontrack</strong></p><p><code>ontrack</code> - это функция обратного вызова (callback), которая вызывается при получении <code>RTP-пакета</code> от удаленного пира. Входящие пакеты помещаются в описание сессии, которое передается в <code>setRemoteDescription</code>.</p><p><strong>oniceconnectionstatechange</strong></p><p><code>oniceconnectionstatechange</code> - это колбэк, который вызывается при изменении состояния агента <code>ICE</code>. Так мы получаем уведомления об установке и завершении соединения.</p><p><strong>onconnectionstatechange</strong></p><p><code>onconnectionstatechange</code> - это комбинация состояния <code>ICE</code> и <code>DTLS</code>. Мы можем использовать этот коллбэк для получения уведомления об успешной установке <code>ICE</code> и <code>DTLS</code>.</p><h2 id="сигнализация" tabindex="-1">Сигнализация <a class="header-anchor" href="#сигнализация" aria-label="Permalink to “Сигнализация”">​</a></h2><p>В момент своего создания агент <code>WebRTC</code> ничего не знает о другом пире. Он не имеет ни малейшего представления о том, с кем будет установлено соединение и чем они будут обмениваться. Сигнализация - это подготовка к совершению звонка. После обмена необходимой информацией агенты могут общаться друг с другом напрямую.</p><p>Сообщения, передаваемые в процессе сигнализации - это просто текст. Агентам неважно, как они передаются (какой транспорт для этого используется). Как правило, они передаются через веб-сокеты, но это необязательно.</p><h3 id="как-это-работает" tabindex="-1">Как это работает? <a class="header-anchor" href="#как-это-работает" aria-label="Permalink to “Как это работает?”">​</a></h3><p><code>WebRTC</code> использует протокол <code>SDP</code>. Через него два агента обмениваются состоянием, необходимым для установки соединения. Сам протокол легко читать. Сложность возникает при изучении значений, генерируемых <code>WebRTC</code>.</p><p>Этот протокол не является специфичным для <code>WebRTC</code>. Сначала мы рассмотрим <code>SDP</code> в отрыве от <code>WebRTC</code>, а после – его применение в <code>WebRTC</code>.</p><h3 id="что-такое-протокол-описания-сессии" tabindex="-1">Что такое протокол описания сессии? <a class="header-anchor" href="#что-такое-протокол-описания-сессии" aria-label="Permalink to “Что такое протокол описания сессии?”">​</a></h3><p>Протокол описания сессии (Session Description Protocol, SDP) определен в <a href="https://datatracker.ietf.org/doc/html/rfc8866" target="_blank" rel="noreferrer">RFC 8866</a>. Он состоит из пар ключ/значение. Каждая пара находится на отдельной строке. Он похож на файл <a href="https://en.wikipedia.org/wiki/INI_file" target="_blank" rel="noreferrer">INI</a>. Описание сессии состоит из 0 и более описаний медиа (media descriptions). Об описании сессии можно думать как о массиве описаний медиа.</p><p>Описание медиа, обычно, относится к определенному потоку медиаданных. Поэтому, если мы хотим описать звонок, содержащий 3 видеопотока и 2 аудиопотока, у нас будет 5 описаний медиа.</p><h4 id="изучение-sdp" tabindex="-1">Изучение SDP <a class="header-anchor" href="#изучение-sdp" aria-label="Permalink to “Изучение SDP”">​</a></h4><p>Каждая новая строка в описании сессии начинается с одного символа - ключа. Затем следует знак равенства. Все остальное (до новой строки) - это значение.</p><p><code>SDP</code> определяет все ключи, которые являются валидными. Для ключей могут использоваться только буквы латинского алфавита. Каждый ключ имеет определенное значение.</p><p>Рассмотрим небольшой кусочек описания сессии:</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=first-value</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=second-value</span></span></code></pre></div><p>У нас есть 2 строки и они обе начинаются с ключа <code>a</code>. Значением первой строки является <code>first-value</code>, а второй - <code>second-value</code>.</p><h4 id="ключи-sdp-используемые-в-webrtc" tabindex="-1">Ключи SDP, используемые в WebRTC <a class="header-anchor" href="#ключи-sdp-используемые-в-webrtc" aria-label="Permalink to “Ключи SDP, используемые в WebRTC”">​</a></h4><p>Не все ключи, определенные в <code>SDP</code>, используются в <code>WebRTC</code>. Используются только ключи, фигурирующие в протоколе установки сессии JavaScript (JavaScript Session Establishment Protocol, <code>JSEP</code>), определенном в <a href="https://datatracker.ietf.org/doc/html/rfc8829" target="_blank" rel="noreferrer">RFC 8829</a>. Прямо сейчас достаточно понимать следующие 7 ключей:</p><ul><li><code>v</code> - версия (version) (<code>0</code>);</li><li><code>o</code> - источник (origin), уникальный идентификатор, полезный для повторной установки соединения;</li><li><code>s</code> - название сессии (<code>-</code>);</li><li><code>t</code> - расчет времени (timing) (<code>0 0</code>);</li><li><code>m</code> - описание медиа (<code>m=&lt;media&gt; &lt;port&gt; &lt;proto&gt; &lt;fmt&gt; ...</code>);</li><li><code>a</code> - атрибут, свободное текстовое поле. Наиболее часто встречающийся ключ;</li><li><code>c</code> - данные о подключении (<code>IN IP4 0.0.0.0</code>).</li></ul><h4 id="медиаописания-в-описании-сессии" tabindex="-1">Медиаописания в описании сессии <a class="header-anchor" href="#медиаописания-в-описании-сессии" aria-label="Permalink to “Медиаописания в описании сессии”">​</a></h4><p>Описание сессии может состоять из неограниченного количества описаний медиа.</p><p>Определение медиаописания состоит из списка форматов (formats). Эти форматы соответствуют типам полезной нагрузки <code>RTP</code> (RTP Payload Types). Кодек определяется атрибутом со значением <code>rtpmap</code> в описании сессии. Каждое описание медиа может состоять из неограниченного количества атрибутов.</p><p>Рассмотрим еще один кусочек описания сессии:</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=audio 4000 RTP/AVP 111</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtpmap:111 OPUS/48000/2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=video 4000 RTP/AVP 96</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtpmap:96 VP8/90000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=my-sdp-value</span></span></code></pre></div><p>У нас есть два описания медиа: одно описывает аудио с форматом <code>111</code>, другое - видео с форматом <code>96</code>. Первое описание содержит один атрибут. Этот атрибут определяет (привязывает, maps) тип полезной нагрузки <code>111</code> как <code>Opus</code>. Второе описание содержит два атрибута. Первый атрибут определяет тип полезной нагрузки <code>96</code> как <code>VP8</code>, второй - содержит кастомное значение <code>my-sdp-value</code>.</p><h4 id="полныи-пример" tabindex="-1">Полный пример <a class="header-anchor" href="#полныи-пример" aria-label="Permalink to “Полный пример”">​</a></h4><p>В следующем примере представлены все ключи <code>SDP</code>, используемые в <code>WebRTC</code>:</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=- 0 0 IN IP4 127.0.0.1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=-</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=IN IP4 127.0.0.1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=0 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=audio 4000 RTP/AVP 111</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtpmap:111 OPUS/48000/2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=video 4002 RTP/AVP 96</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtpmap:96 VP8/90000</span></span></code></pre></div><ul><li><code>v</code>, <code>o</code>, <code>s</code>, <code>c</code> и <code>t</code> определены, но они не влияют на сессию <code>WebRTC</code>;</li><li>у нас имеется два описания медиа. Одно с типом <code>audio</code>, другое - <code>video</code>;</li><li>каждое описание содержит один атрибут. Он определяет детали <a href="https://en.wikipedia.org/wiki/Pipeline_(software)" target="_blank" rel="noreferrer">конвейера</a> (pipeline) <code>RTP</code>.</li></ul><h3 id="как-sdp-и-webrtc-работают-вместе" tabindex="-1">Как SDP и WebRTC работают вместе <a class="header-anchor" href="#как-sdp-и-webrtc-работают-вместе" aria-label="Permalink to “Как SDP и WebRTC работают вместе”">​</a></h3><p>Следующим кусочком пазла является понимание того, как <code>WebRTC</code> использует <code>SDP</code>.</p><h4 id="что-такое-предложения-и-ответы" tabindex="-1">Что такое предложения и ответы? <a class="header-anchor" href="#что-такое-предложения-и-ответы" aria-label="Permalink to “Что такое предложения и ответы?”">​</a></h4><p><code>WebRTC</code> использует модель предложение/ответ (offer/answer). Это означает, что если один агент &quot;предлагает&quot; начать коммуникацию, другой агент &quot;отвечает&quot;, хочет он этого или нет.</p><p>Это позволяет отвечающему отклонить неподдерживаемые им кодеки, указанные в описаниях медиа. Таким способом пиры определяют, какими форматами данных они будут обмениваться.</p><h4 id="трансиверы" tabindex="-1">Трансиверы <a class="header-anchor" href="#трансиверы" aria-label="Permalink to “Трансиверы”">​</a></h4><p>Трансиверы (приемопередатчики, transceivers) - это специфическая для <code>WebRTC</code> концепция, которую вы встретите в <code>API</code>. Их основной задачей является преобразование &quot;описания медиа&quot; в <code>JavaScript API</code>. Каждое описание медиа становится трансивером. При каждом создании трансивера в локальное описание сессии добавляется новое описание медиа.</p><p>Каждое описание сессии в <code>WebRTC</code> имеет атрибут, определяющий направление передачи данных (direction). Это позволяет агенту объявлять такие вещи, как, например, &quot;Я собираюсь отправить тебе этот кодек, но не хочу ничего получать в ответ&quot;. Валидными значениями направления являются:</p><ul><li><code>send</code> (sendonly, sending - отправка);</li><li><code>recv</code> (recvonly, receiving - получение);</li><li><code>sendrecv</code> (отправка и получение);</li><li><code>inactive</code> (неактивное состояние).</li></ul><h4 id="значения-sdp-используемые-в-webrtc" tabindex="-1">Значения SDP, используемые в WebRTC <a class="header-anchor" href="#значения-sdp-используемые-в-webrtc" aria-label="Permalink to “Значения SDP, используемые в WebRTC”">​</a></h4><p>Ниже представлен список некоторых часто встречающихся атрибутов описания сессии, используемых агентами. Многие из этих значений контролируют подсистемы, которые мы еще не обсуждали (но скоро обсудим).</p><p><strong>group:BUNDLE</strong></p><p>Сборка (bundling) - это передача нескольких типов трафика через одно соединение (часто это называют <a href="https://en.wikipedia.org/wiki/Batch_processing" target="_blank" rel="noreferrer">&quot;батчингом&quot;</a>, batching). В некоторых реализациях <code>WebRTC</code> для каждого медиапотока выделяется отдельное соединение. Сборка является предпочтительной.</p><p><strong>fingerprint:sha-256</strong></p><p>Это <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%81%D1%83%D0%BC%D0%BC%D0%B0" target="_blank" rel="noreferrer">хеш</a> сертификата, используемого пиром для <code>DTLS</code>. После завершения рукопожатия <code>DTLS</code> мы сравниваем хеш с сертификатом для подтверждения того, что мы общаемся с тем, кого ожидаем.</p><p><strong>setup:</strong></p><p>Контролирует поведение агента <code>DTLS</code>. Определяет, чем является агент (клиентом или сервером), после установки <code>ICE</code>. Возможные значения:</p><ul><li><code>setup:active</code> - запуск в качестве клиента <code>DTLS</code>;</li><li><code>setup:passive</code> - запуск в качестве сервера <code>DTLS</code>;</li><li><code>setup:actpass</code> - просим другого агента <code>WebRTC</code> сделать выбор.</li></ul><p><strong>ice-ufrag</strong></p><p>Значение фрагмента пользователя (user fragment) для агента <code>ICE</code>. Используется для аутентификации трафика <code>ICE</code>.</p><p><strong>ice-pwd</strong></p><p>Пароль для агента <code>ICE</code>. Используется для аутентификации трафика <code>ICE</code>.</p><p><strong>rtpmap</strong></p><p>Используется для определения связи между конкретным кодеком и типом полезной нагрузки <code>RTP</code>. Типы полезной нагрузки являются динамическими, поэтому для каждого вызова его инициатор выбирает типы полезной нагрузки для каждого кодека.</p><p><strong>fmtp</strong></p><p>Определяет дополнительные значения типа полезной нагрузки. Может использоваться для настройки профиля видео или кодировки.</p><p><strong>candidate</strong></p><p>Кандидат <code>ICE</code>, полученный от агента <code>ICE</code>. Один из адресов, по которым доступен агент <code>WebRTC</code>.</p><p><strong>ssrc</strong></p><p>Определяет конкретный трек медиапотока (media stream track).</p><p><code>label</code> - это идентификатор потока. <code>mslabel</code> - идентификатор контейнера, который может содержать несколько потоков.</p><h4 id="пример-описания-сессии" tabindex="-1">Пример описания сессии <a class="header-anchor" href="#пример-описания-сессии" aria-label="Permalink to “Пример описания сессии”">​</a></h4><p>Полное описание сессии, генерируемое клиентом <code>WebRTC</code>:</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=- 3546004397921447048 1596742744 IN IP4 0.0.0.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=-</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=0 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=group:BUNDLE 0 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=audio 9 UDP/TLS/RTP/SAVPF 111</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=IN IP4 0.0.0.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=setup:active</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=mid:0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ice-ufrag:CsxzEWmoKpJyscFj</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtcp-mux</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtcp-rsize</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtpmap:111 opus/48000/2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=fmtp:111 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">minptime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">;useinbandfec=1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ssrc:350842737 cname:yvKPspsHcYcwGFTw</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ssrc:350842737 label:DfQnKjQQuwceLFdV</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=sendrecv</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=end-of-candidates</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=video 9 UDP/TLS/RTP/SAVPF 96</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=IN IP4 0.0.0.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=setup:active</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=mid:1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ice-ufrag:CsxzEWmoKpJyscFj</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtcp-mux</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtcp-rsize</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=rtpmap:96 VP8/90000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=ssrc:2180035812 label:JgtwEhBWNEiOnhuW</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=sendrecv</span></span></code></pre></div><p>Вот что мы должны понять из этого сообщения:</p><ul><li>у нас имеется два медиараздела: один для аудио и один для видео;</li><li>оба являются трансиверами <code>sendrecv</code>. Мы получаем два потока и можем отправить два потока в ответ;</li><li>у нас имеются кандидаты <code>ICE</code> и детали аутентификации, что позволяет предпринять попытку установить соединение;</li><li>у нас имеется отпечаток сертификата, что позволяет сделать звонок безопасным.</li></ul><h2 id="подключение" tabindex="-1">Подключение <a class="header-anchor" href="#подключение" aria-label="Permalink to “Подключение”">​</a></h2><p>Большинство разрабатываемых сегодня приложений реализует клиент-серверную архитектуру подключения. Такая архитектура предполагает наличие сервера с известным и стабильным транспортным адресом (transport address) (<code>IP</code> и порт). Клиент отправляет запрос, а сервер на него отвечает.</p><p>В <code>WebRTC</code> используется другая архитектура - одноранговая сеть (Peer-to-Peer, P2P). В такой сети задача установки соединения распределяется между пирами. Это обусловлено тем, что транспортный адрес не может быть определен заранее, и может меняться в течение сессии (session). <code>WebRTC</code> собирает всю доступную информацию и делает многое для обеспечения возможности двунаправленной коммуникации (bi-directional communication) между агентами.</p><p>Установка такого соединения - задача не из простых. Агенты могут находиться в разных сетях, т.е. не иметь прямого соединения. И даже если оно есть, могут быть другие проблемы. Например, клиенты могут использовать разные протоколы (<code>UPD &lt;-&gt; TCP</code>) или разные версии <code>IP</code> (<code>IPv4 &lt;-&gt; IPv6</code>).</p><p>Несмотря на это, <code>WebRTC</code> предоставляет некоторые преимущества по сравнению с клиент-серверной архитектурой.</p><p><strong>Уменьшение размера передаваемых данных</strong></p><p>Поскольку обмен данными между агентами осуществляется напрямую, нам не нужно &quot;платить&quot; за сервер, предназначенный для ретрансляции (перенаправления) этих данных.</p><p><strong>Снижение задержки</strong></p><p>Прямая коммуникация является более быстрой. Когда пользователь вынужден отправлять данные через сервер, ретрансляция увеличивает задержку.</p><p><strong>Повышение безопасности</strong></p><p>Прямая коммуникация является более безопасной. Поскольку сервер не участвует в передаче данных, пользователи могут быть уверены, что данные не будут расшифрованы, пока не достигнут адресата.</p><h3 id="как-это-работает-1" tabindex="-1">Как это работает? <a class="header-anchor" href="#как-это-работает-1" aria-label="Permalink to “Как это работает?”">​</a></h3><p>Описанный выше процесс называется <a href="https://datatracker.ietf.org/doc/html/rfc8445" target="_blank" rel="noreferrer">установкой интерактивного соединения</a> (Interactive Connectivity Establishment, ICE).</p><p><code>ICE</code> - это протокол, который пытается определить наилучший способ для установки соединения между двумя агентами. Каждый агент публикует (publishes) путь, по которому он может быть достигнут (reachable). Такие пути называются кандидатами (candidates). По сути, кандидат - это транспортный адрес, который один агент считает достижимым для другого агента. Затем <code>ICE</code> определяет наиболее подходящую пару кандидатов.</p><p>Для того, чтобы убедиться в необходимости <code>ICE</code>, нужно понимать, какие трудности нам приходится преодолевать на пути установки интерактивного соединения.</p><h3 id="ограничения-реального-мира" tabindex="-1">Ограничения реального мира <a class="header-anchor" href="#ограничения-реального-мира" aria-label="Permalink to “Ограничения реального мира”">​</a></h3><p>Основное назначение <code>ICE</code> - преодоление ограничений, накладываемых на подключение реальным миром. Кратко обсудим эти ограничения.</p><h4 id="разные-сети" tabindex="-1">Разные сети <a class="header-anchor" href="#разные-сети" aria-label="Permalink to “Разные сети”">​</a></h4><p>В большинстве случаев второй агент будет находиться в другой сети. Как правило, соединение устанавливается между агентами, находящимися в разных сетях.</p><p>Ниже представлен граф двух независимых сетей, соединенных вместе через публичный Интернет. В каждой сети у нас имеется два хоста.</p><img src="https://habrastorage.org/webt/6d/aj/pa/6dajpadwe3lnahtlj3mlya1ubnw.png" alt=""><br><p>Для хостов, находящихся в одной сети, установка соединения - простая задача. Коммуникацию между <code>192.168.0.1 -&gt; 192.168.0.2</code> легко организовать. Такие хосты могут общаться друг с другом без посторонней помощи.</p><p>Однако, хост, использующий <code>Router B</code>, не имеет возможности общаться с хостами, использующими <code>Router A</code>. Как определить разницу между <code>192.168.0.1</code> из <code>Router A</code> и таким же <code>IP</code> из <code>Router B</code>? Эти <code>IP</code> являются частными (закрытыми для внешнего мира, private)! Хост из <code>Router B</code> может отправлять данные в <code>Router A</code>, но запрос завершится ничем. Как <code>Router A</code> определить, какому хосту следует передавать сообщение?</p><h4 id="ограничения-протоколов" tabindex="-1">Ограничения протоколов <a class="header-anchor" href="#ограничения-протоколов" aria-label="Permalink to “Ограничения протоколов”">​</a></h4><p>В одних сетях запрещена передача трафика по <code>UDP</code>, в других - по <code>TCP</code>. Некоторые сети могут иметь очень низкую <a href="https://ru.wikipedia.org/wiki/Maximum_transmission_unit" target="_blank" rel="noreferrer">максимальную единицу передачи данных</a> (Maximum Transmission Unit, MTU). Существует большое количество настроек сетей, которые могут сделать коммуникацию по меньшей мере затруднительной.</p><h4 id="правила-межсетевых-экранов" tabindex="-1">Правила межсетевых экранов <a class="header-anchor" href="#правила-межсетевых-экранов" aria-label="Permalink to “Правила межсетевых экранов”">​</a></h4><p>Еще одной проблемой является &quot;глубокая проверка пакетов&quot; (&quot;Deep Packet Inspection&quot;) и другая фильтрация сетевого трафика. Некоторые сетевые администраторы применяют такое программное обеспечение в отношении каждого пакета. Во многих случаях это ПО не понимает <code>WebRTC</code>, считает пакеты <code>WebRTC</code> подозрительными пакетами <code>UDP</code>, передаваемыми по порту, не входящему в <a href="https://en.wikipedia.org/wiki/Whitelisting" target="_blank" rel="noreferrer">белый список</a> (whitelist).</p><h3 id="отображение-nat" tabindex="-1">Отображение NAT <a class="header-anchor" href="#отображение-nat" aria-label="Permalink to “Отображение NAT”">​</a></h3><p>Отображение результата <a href="https://ru.wikipedia.org/wiki/NAT" target="_blank" rel="noreferrer">преобразования сетевых адресов</a> (Network Address Translation, NAT) (NAT Mapping) - это магия, которая делает подключение <code>WebRTC</code> возможным. Это то, благодаря чему два пира из разных сетей могут общаться друг с другом. Рассмотрим, как работает отображение <code>NAT</code>.</p><p><code>NAT</code> не использует ретранслятор, прокси или сервер. У нас есть <code>Agent 1</code> и <code>Agent 2</code>, которые находятся в разных сетях. Несмотря на это, они могут обмениваться данными. Вот как это выглядит:</p><img src="https://habrastorage.org/webt/tf/am/-8/tfam-87ok_feb9rduj6kx3oguxc.png" alt=""><br><p>Для обеспечения возможности подобной коммуникации мы прибегаем к помощи отображения <code>NAT</code>. <code>Agent 1</code> использует порт <code>7000</code> для установки соединения <code>WebRTC</code> с <code>Agent 2</code>. <code>192.168.0.1:7000</code> привязывается (bind) к <code>5.0.0.1:7000</code>. Это позволяет <code>Agent 2</code> &quot;достигать&quot; <code>Agent 1</code>, отправляя пакеты по адресу <code>5.0.0.1:7000</code>. Создание отображения <code>NAT</code> похоже на автоматическую версию переадресации портов (port forwarding) в роутере.</p><p>Обратной стороной <code>NAT</code> является то, что не существует единой формы отображения (например, статической переадресации портов), в разных сетях поведение может быть различным. Интернет-провайдеры и производители аппаратного обеспечения могут делать это по-разному. В некоторых случаях сетевые администраторы вообще могут его отключить.</p><p>Хорошей новостью является то, что все эти особенности мониторятся и учитываются, что позволяет агенту <code>ICE</code> создавать отображение <code>NAT</code> и его атрибуты.</p><p>Документом, описывающим данный процесс, является <a href="https://datatracker.ietf.org/doc/html/rfc4787" target="_blank" rel="noreferrer">RFC 4787</a>.</p><h4 id="создание-отображения-nat" tabindex="-1">Создание отображения NAT <a class="header-anchor" href="#создание-отображения-nat" aria-label="Permalink to “Создание отображения NAT”">​</a></h4><p>Создание отображения - самая легкая часть. Отображение создается, когда мы отправляем пакет по адресу, находящемуся за пределами нашей сети. Отображение <code>NAT</code> - это просто временные публичные <code>IP</code> и порт, занимаемый нашим <code>NAT</code>. Исходящие сообщения переписываются таким образом, что адресом их источника (source address) становится созданное отображение. При отправке сообщения в отображение, оно автоматически перенаправляется в хост внутри создавшего его <code>NAT</code>. И этот процесс становится сложным, когда речь заходит о деталях создания отображения.</p><h4 id="варианты-создания-отображения-nat" tabindex="-1">Варианты создания отображения NAT <a class="header-anchor" href="#варианты-создания-отображения-nat" aria-label="Permalink to “Варианты создания отображения NAT”">​</a></h4><p>Создание отображение делится на три категории.</p><p><strong>Автономное (не зависящее от конечной точки, endpoint-independent) отображение</strong></p><p>Для каждого отправителя внутри <code>NAT</code> создается отдельное отображение. Если мы отправляем два пакета по двум удаленным адресам, для обоих пакетов используется одно и то же отображение. Оба удаленных хоста будут видеть один и тот же <code>IP</code> и порт источника. При получении ответов от хостов, они передаются в один и тот же локальный обработчик (local listener).</p><p>Это лучший сценарий. Для осуществления звонка необходимо, чтобы хотя бы одна сторона была такого типа.</p><p><strong>Зависящее от адреса (address dependent) отображение</strong></p><p>Новое отображение создается при отправке пакета по новому адресу. Если мы отправляем два пакета в два разных хоста, создается два отображения. Если мы отправляем два пакета в один удаленный хост, но разные порты, создается ОДНО отображение.</p><p><strong>Зависящее от адреса и порта отображение</strong></p><p>Новое отображение создается, если отличаются удаленный <code>IP</code> или порт. Если мы отправляем два пакета в один удаленный хост, но в разные порты, создается два отображения.</p><h4 id="варианты-фильтрации-отображения-nat" tabindex="-1">Варианты фильтрации отображения NAT <a class="header-anchor" href="#варианты-фильтрации-отображения-nat" aria-label="Permalink to “Варианты фильтрации отображения NAT”">​</a></h4><p>Фильтрация отображения - это правила, определяющие, кто может использовать отображение. Существует три возможных варианта:</p><p><strong>Автономная фильтрация</strong></p><p>Отображение может использовать кто угодно. Мы можем делиться им с другими пирами, и они смогут отправлять в него трафик.</p><p><strong>Зависящая от адреса фильтрация</strong></p><p>Отображение может использовать только создавший его хост. Если мы отправляем пакет в хост <code>A</code>, он может отправить в ответ любое количество пакетов. Если хост <code>B</code> отправит пакет в это отображение, данный пакет будет игнорироваться (will be ignored).</p><p><strong>Зависящая от адреса и порта фильтрация</strong></p><p>Отображение может использоваться только создавшим его хостом и портом. Если мы отправляем пакет в хост <code>A:5000</code>, он может ответить любым количеством пакетов. Пакет, отправленный хостом <code>A:5001</code>, будет игнорироваться.</p><h4 id="обновление-отображения-nat" tabindex="-1">Обновление отображения NAT <a class="header-anchor" href="#обновление-отображения-nat" aria-label="Permalink to “Обновление отображения NAT”">​</a></h4><p>Рекомендуется уничтожать (destroy) отображение, которое не используется в течение пяти минут, но это зависит от Интернет-провайдеров и производителей &quot;железа&quot;.</p><h3 id="stun" tabindex="-1">STUN <a class="header-anchor" href="#stun" aria-label="Permalink to “STUN”">​</a></h3><p><a href="https://ru.wikipedia.org/wiki/STUN" target="_blank" rel="noreferrer">Утилиты прохождения сессий для NAT</a> (Session Traversal Utilities for NAT, STUN) - это протокол, предназначенный для работы с <code>NAT</code>. Он определен в <a href="https://tools.ietf.org/html/rfc8489" target="_blank" rel="noreferrer">RFC 8489</a>, в котором также определяется структура пакетов <code>STUN</code>. Протокол <code>STUN</code> также используется <code>ICE/TURN</code>.</p><p><code>STUN</code> позволяет программно создавать отображения <code>NAT</code>. До <code>STUN</code> мы могли создавать отображения, но не могли получать информацию о созданных <code>IP</code> и портах. <code>STUN</code> не только позволяет создавать отображения, он также предоставляет информацию, которой можно поделиться с другими для того, чтобы они могли передавать данные в отображение.</p><p>Начнем с базового описания <code>STUN</code>. Позже мы рассмотрим, как <code>STUN</code> используется в <code>ICE</code> и <code>TURN</code>. Рассмотрим процесс запрос/ответ (request/response) для создания отображения, а также поговорим о том, как получить информацию об <code>IP</code> и портах. Данный процесс происходит, когда у нас есть сервер <code>stun:</code> в путях (urls) <code>ICE</code> для <code>WebRTC PeerConnection</code> (например, <code>new RTCPeerConnection({ iceServers: [{ urls: [&#39;stun:stun.l.google.com:19302&#39;] }] })</code>). <code>STUN</code> помогает конечной точке, находящейся за <code>NAT</code>, получить детали о созданном отображении, путем отправки запроса к серверу <code>STUN</code> о предоставлении информации о том, что он видит извне (observes).</p><h4 id="структура-протокола" tabindex="-1">Структура протокола <a class="header-anchor" href="#структура-протокола" aria-label="Permalink to “Структура протокола”">​</a></h4><p>Каждый пакет <code>STUN</code> имеет следующую структуру:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|0 0|     STUN Message Type     |         Message Length        |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                         Magic Cookie                          |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                                                               |</span></span>
<span class="line"><span>|                     Transaction ID (96 bits)                  |</span></span>
<span class="line"><span>|                                                               |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                             Data                              |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p><strong>STUN Message Type</strong></p><p>Тип пакета. В данный момент нас интересует следующее:</p><ul><li>запрос на привязку или связывание (Binding Request) - <code>0x0001</code>;</li><li>ответ на привязку (Binding Response) - <code>0x0101</code>.</li></ul><p>Для создания отображения <code>NAT</code> мы выполняем <code>Binding Request</code>. Сервер отправляет нам <code>Binding Response</code>.</p><p><strong>Message Length</strong></p><p>Длина раздела <code>Data</code> (размер данных). Этот раздел содержит данные, определенные в <code>Message Type</code>.</p><p><strong>Magic Cookie</strong></p><p>Фиксированное значение <code>0x2112A442</code> в сетевом порядке байтов (network byte order). Это помогает отличать <code>STUN</code> от других протоколов.</p><p><strong>Transaction ID</strong></p><p>96-битный идентификатор, уникально определяющий запрос/ответ. Это помогает определять пары запросов и ответов.</p><p><strong>Data</strong></p><p>Данные содержат список атрибутов <code>STUN</code>. Атрибут <code>STUN</code> имеет следующую структуру:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|         Type                  |            Length             |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                         Value (variable)                ....</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p><code>STUN Binding Request</code> не использует атрибуты. Это означает, что в запросе содержится только заголовок (header).</p><p><code>STUN Binding Response</code> использует <code>XOR-MAPPED-ADDRESS (0x0020)</code>. Данный атрибут содержит <code>IP</code> и порт из отображения <code>NAT</code>.</p><h4 id="создание-отображения-nat-1" tabindex="-1">Создание отображения NAT <a class="header-anchor" href="#создание-отображения-nat-1" aria-label="Permalink to “Создание отображения NAT”">​</a></h4><p>&quot;Цена&quot; создания отображения <code>NAT</code> с помощью <code>STUN</code> - один запрос. Мы отправляем <code>Binding Request</code> серверу <code>STUN</code>. Он возвращает нам <code>Binding Response</code>. <code>Binding Response</code> содержит <code>Mapped Address</code>. <code>Mapped Address</code> - то, как сервер <code>STUN</code> видит отображение <code>NAT</code>. <code>Mapped Address</code> - то, что может использоваться другой стороной для отправки данных в наш адрес.</p><p><code>Mapped Address</code> - это наш <code>Public IP</code> (публичный адрес) или <code>Server Reflexive Candidate</code> в терминологии <code>WebRTC</code>.</p><h4 id="определение-типа-nat" tabindex="-1">Определение типа NAT <a class="header-anchor" href="#определение-типа-nat" aria-label="Permalink to “Определение типа NAT”">​</a></h4><p>К сожалению, <code>Mapped Address</code> может использоваться не во всех случаях. Если <code>NAT</code> является зависящим от адреса, мы можем получать данные только от сервера <code>STUN</code>. В этом случае сообщения, отправленные другой стороной в <code>Mapped Address</code>, будут потеряны (will be dropped). Это делает <code>Mapped Address</code> бесполезным. И проблема эта решается тем, что сервер <code>STUN</code> перенаправляет пакеты к пиру. Такое решение называется <code>TURN</code>.</p><p><a href="https://tools.ietf.org/html/rfc5780" target="_blank" rel="noreferrer">RFC 5780</a> описывает метод для определения типа <code>NAT</code>. Это позволяет заранее определить возможность установки прямого соединения.</p><h3 id="turn" tabindex="-1">TURN <a class="header-anchor" href="#turn" aria-label="Permalink to “TURN”">​</a></h3><p><a href="https://ru.wikipedia.org/wiki/Traversal_Using_Relay_NAT" target="_blank" rel="noreferrer">Отображение NAT с помощью ретрансляторов</a> (Traversal Using Relays around NAT, TURN), определенный в <a href="https://datatracker.ietf.org/doc/html/rfc8656" target="_blank" rel="noreferrer">RFC 8656</a>, это решение проблемы отсутствия возможности прямого соединения. Такое может произойти при несовместимости типов <code>NAT</code> или использовании разных протоколов агентами. <code>TURN</code> также может использоваться для обеспечения конфиденциальности. Создавая коммуникацию с помощью <code>TURN</code>, мы обфусцируем (скрываем) настоящие адреса клиентов.</p><p><code>TURN</code> использует выделенный сервер. Этот сервер является прокси для клиента. Клиент подключается к серверу <code>TURN</code> и создает <code>Allocation</code> (размещение). Ему выделяется временный <code>IP</code>/порт/протокол, который может использоваться для передачи данных. Данный обработчик называется <code>Relayed Transport Address</code>. Это своего рода адрес переадресации (forwarding address), который может использоваться другой стороной для передачи трафика через <code>TURN</code>. Для каждого пира создается отдельный <code>Relayed Transport Address</code>, что требует предоставления <code>Permission</code> (разрешения) на коммуникацию.</p><p>При передаче трафика через <code>TURN</code>, он передается через <code>Relayed Transport Address</code>. При получении трафика удаленным пиром, он видит, что трафик пришел от <code>TURN</code>.</p><h4 id="жизненныи-цикл-turn" tabindex="-1">Жизненный цикл TURN <a class="header-anchor" href="#жизненныи-цикл-turn" aria-label="Permalink to “Жизненный цикл TURN”">​</a></h4><p>Поговорим о том, что должен сделать клиент, который хочет создать размещение в <code>TURN</code>. Коммуникация с тем, кто использует <code>TURN</code>, не требует совершения дополнительных действий. Другой пир просто получает <code>IP</code> и порт, которые могут использоваться для передачи данных.</p><p><strong>Размещения</strong></p><p>Размещения - ядро <code>TURN</code>. <code>Allocation</code> - &quot;сессия <code>TURN</code>&quot;. Для создания размещения в <code>TURN</code> мы обращаемся к <code>Server Transport Address</code> сервер <code>TURN</code> (портом по умолчанию является <code>3478</code>).</p><p>При создании размещения серверу необходимо предоставить следующую информацию:</p><ul><li>имя пользователя/пароль - создание размещения требует аутентификации;</li><li>транспорт, используемый размещением - транспортный протокол между сервером (<code>Server Transport Address</code>) и пирами: <code>UDP</code> или <code>TCP</code>;</li><li><code>Even-Port</code> - мы можем запрашивать последовательность портов для нескольких размещений, не относящихся к <code>WebRTC</code>.</li></ul><p>При успешном запросе мы получаем от сервера <code>TURN</code> ответ со следующими атрибутами в разделе <code>Data</code>:</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>Mapped Address</code> клиента <code>TURN</code> (TURN Client). При отправке данных в <code>Relayed Transport Address</code>, они перенаправляются в этот адрес;</li><li><code>RELAYED-ADDRESS</code> - адрес, передаваемый другим клиентам. При отправке пакета по этому адресу, он передается клиенту <code>TURN</code>;</li><li><code>LIFETIME</code> - сколько времени осталось до уничтожения размещения <code>TURN</code>. Время жизни размещения может быть увеличено через отправку запроса <code>Refresh</code>.</li></ul><p><strong>Разрешения</strong></p><p>Удаленный хост не может отправлять данные в наш <code>Relayed Transport Address</code> до тех пор, пока мы не предоставим ему разрешение. При создании разрешения мы говорим серверу <code>TURN</code>, что указанным <code>IP</code> и порту разрешен входящий трафик.</p><p>Удаленный хост должен предоставить нам <code>IP</code> и порт в том виде, в каком они отображаются на сервере <code>TURN</code>. Это означает, что он должен отправить <code>STUN Binding Request</code>. Распространенной ошибкой является отправка такого запроса не тому серверу <code>TURN</code>. После отправки запроса удаленный хост обращается к нам с просьбой о предоставлении разрешения.</p><p>Предположим, что мы хотим создать разрешение для хоста, находящегося за <code>Address Dependent Mapping</code>. Если мы получим <code>Mapped Address</code> от другого сервера <code>TURN</code>, весь входящий трафик будет потерян. При каждом взаимодействии с другим хостом создается новое отображение. Время жизни разрешения составляет 5 минут.</p><p><strong>SendIndication/ChannelData</strong></p><p>Эти сообщения предназначены для клиента <code>TURN</code> для отправки сообщений удаленному пиру.</p><p><code>SendIndication</code> - самодостаточное сообщение. Внутри него находятся данные для отправки, а также адресат. Отправка большого количества сообщений удаленному пиру является расточительной. При отправке 1000 сообщений <code>IP</code> адрес удаленного пира будет повторен 1000 раз!</p><p><code>ChannelData</code> позволяет отправлять данные без дублирования <code>IP-адреса</code>. Мы создаем канал (channel) с <code>IP</code> и портом. При отправке сообщения в нем указывается <code>ChannelId</code>, а <code>IP</code> и порт заполняются сервером. Это позволяет уменьшить нагрузку на сервер при отправке большого количества сообщений.</p><p><strong>Обновление</strong></p><p>Размещения уничтожаются автоматически. Для сохранения размещения его <code>LIFETIME</code> (время жизни) должно периодически обновляться.</p><h4 id="использование-turn" tabindex="-1">Использование TURN <a class="header-anchor" href="#использование-turn" aria-label="Permalink to “Использование TURN”">​</a></h4><p><code>TURN</code> может использоваться в двух формах. Как правило, у нас имеется один пир, выступающий в роли &quot;клиента <code>TURN</code>&quot;, и другой сторона, обращающаяся к &quot;клиенту&quot; напрямую. В некоторых случаях может потребоваться использовать <code>TURN</code> на обеих сторонах, например, по причине того, что обе стороны находятся в сетях, блокирующих <code>UDP</code>, поэтому соединение с соответствующими серверами <code>TURN</code> выполняется через <code>TCP</code>.</p><p><strong>Одна аллокация TURN для коммуникации</strong></p><img src="https://habrastorage.org/webt/8n/na/ah/8nnaahtbdukwvf40milw0dgfbim.png" alt=""><br><p><strong>Две аллокации TURN для коммуникации</strong></p><img src="https://habrastorage.org/webt/13/yy/qp/13yyqpl0xsojihqa1rycg1qg1k4.png" alt=""><br><h3 id="ice" tabindex="-1">ICE <a class="header-anchor" href="#ice" aria-label="Permalink to “ICE”">​</a></h3><p><code>ICE</code> - то, как <code>WebRTC</code> подключает двух агентов. Этот протокол определен в <a href="https://datatracker.ietf.org/doc/html/rfc8445" target="_blank" rel="noreferrer">RFC 8445</a>. <code>ICE</code> - протокол для установки соединения. Он описывает все возможные маршруты (routes) между двумя пирами и обеспечивает стабильность подключения.</p><p>Эти роуты называются <code>Candidate Pairs</code> (парами кандидатов) и представляют собой пару локального и удаленного транспортных адресов. Вот где в игру вступают <code>STUN</code> и <code>TURN</code>. Эти адреса могут быть нашими локальными <code>IP</code> и портом, отображением <code>NAT</code> или <code>Relayed Transport Address</code>. Каждая сторона собирает адреса, которые она хочет (и может) использовать, передает их другой стороне и выполняет попытку подключения.</p><p>Два агента <code>ICE</code> взаимодействуют с помощью пинг-пакетов (ping packets) <code>ICE</code> (которые формально называются проверками подключения - connectivity checks) для установки соединения. После установки соединения стороны могут обмениваться данными. Это похоже на использование обычных <a href="https://ru.wikipedia.org/wiki/WebSocket" target="_blank" rel="noreferrer">веб-сокетов</a>. Все необходимые проверки выполняются с помощью протокола <code>STUN</code>.</p><h4 id="создание-агента-ice" tabindex="-1">Создание агента ICE <a class="header-anchor" href="#создание-агента-ice" aria-label="Permalink to “Создание агента ICE”">​</a></h4><p>Агент <code>ICE</code> может быть <code>Controlling</code> (управляющим) или <code>Controlled</code> (управляемым). Управляющий агент - это тот, который выбирает <code>Candidate Pair</code>. Как правило, пир, отправляющий предложение об установке соединения (offer), является управляющей стороной.</p><p>Каждая сторона должна иметь <code>user fragment</code> и <code>password</code>. Стороны должны обменяться этими значениями до начала проверок подключения. <code>user fragment</code> отправляется в виде обычного текста и может использоваться для демультиплексирования (demuxing) нескольких сеансов <code>ICE</code>. <code>password</code> используется для генерации атрибута <code>MESSAGE-INTEGRITY</code>. В конце каждого пакета <code>STUN</code> имеется атрибут с <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" target="_blank" rel="noreferrer">хешем</a> содержимого пакета - <code>password</code> используется в качестве ключа. Это позволяет аутентифицировать пакет, т.е. убедиться в том, что он не был подменен или модифицирован в процессе передачи.</p><p>В случае с <code>WebRTC</code> эти значения передаются через <code>Session Description</code> (описание сессии), о котором рассказывалось в предыдущем разделе.</p><h4 id="сбор-кандидатов-candidate-gathering" tabindex="-1">Сбор кандидатов (Candidate Gathering) <a class="header-anchor" href="#сбор-кандидатов-candidate-gathering" aria-label="Permalink to “Сбор кандидатов (Candidate Gathering)”">​</a></h4><p>Теперь нам необходимо собрать все адреса, по которым достижимы агенты. Эти адреса называются кандидатами.</p><p><strong>Хост</strong></p><p>Кандидат хоста предоставляется локальным интерфейсом. Это может быть <code>UDP</code> или <code>TCP</code>.</p><p><strong>mDNS</strong></p><p>Кандидат <code>mDNS</code> похож на кандидата хоста, но его <code>IP-адрес</code> скрывается. Вместо <code>IP-адреса</code> другой стороне предоставляется <a href="https://ru.wikipedia.org/wiki/UUID" target="_blank" rel="noreferrer"><code>UUID</code></a> в качестве названия хоста. После этого мы настраиваем многоадресный обработчик (multicast listener), который отвечает на запросы к опубликованному <code>UUID</code>.</p><p>Если мы находимся в одной сети с агентом, мы можем найти друг друга через <a href="https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%B2%D0%B5%D1%89%D0%B0%D0%BD%D0%B8%D0%B5" target="_blank" rel="noreferrer">мультикаст</a> (multicast). Если мы и агент находимся в разных сетях, установить соединение не получится. Как минимум, до тех пор, пока администратор сети явно не разрешит такую передачу пакетов.</p><p>Это позволяет обеспечить конфиденциальность. В случае с кандидатом хоста пользователь видит наш <code>IP</code> адрес через <code>WebRTC</code> (даже не пытаясь установить соединение), но в случае с кандидатом <code>mDNS</code> он получит только случайный <code>UUID</code>.</p><p><strong>Server Reflexive</strong></p><p>Кандидат от сервера (Server Reflexive Candidate) генерируется сервером <code>STUN</code> в ответ на <code>STUN Binding Request</code>.</p><p>При получении <code>STUN Binding Response</code> содержащийся в нем <code>XOR-MAPPED-ADDRESS</code> - это наш кандидат от сервера.</p><p><strong>Peer Reflexive</strong></p><p>Кандидат от пира (Peer Reflexive Candidate) - это когда мы получаем входящий запрос от неизвестного адреса . Поскольку <code>ICE</code> - это протокол с аутентификацией, мы знаем, что трафик является валидным. Это всего лишь означает, что удаленный пир общается с нами с неизвестного адреса.</p><p>Это обычно происходит при общении <code>Host Candidate</code> с <code>Server Reflexive Candidate</code>. Поскольку мы общаемся за пределами нашей подсети, создается новое отображение <code>NAT</code>. Помните, мы говорили о том, что проверки подключения - это на самом деле пакеты <code>STUN</code>? Формат ответа <code>STUN</code> позволяет пиру вернуть адрес кандидата от пира (peer-reflexive address).</p><p><strong>Relay</strong></p><p>Релейный кандидат генерируется сервером <code>TURN</code>.</p><p>После первоначального рукопожатия (handshake) мы получаем <code>RELAYED-ADDRESS</code> - наш релейный кандидат.</p><h4 id="проверки-подключения" tabindex="-1">Проверки подключения <a class="header-anchor" href="#проверки-подключения" aria-label="Permalink to “Проверки подключения”">​</a></h4><p>Теперь мы знаем <code>user fragment</code>, <code>password</code> и кандидатов удаленного агента. Выполняем попытку подключения! Кандидаты разбиваются попарно. Поэтому если у нас было три кандидата от каждой стороны, мы получаем девять пар кандидатов.</p><p>Вот как это выглядит:</p><img src="https://habrastorage.org/webt/ev/fd/i-/evfdi-n53jzyix7u_ut-hb-srxo.png" alt=""><br><h4 id="выбор-кандидатов" tabindex="-1">Выбор кандидатов <a class="header-anchor" href="#выбор-кандидатов" aria-label="Permalink to “Выбор кандидатов”">​</a></h4><p>Управляющий и управляемый агенты начинают передавать трафик через каждую пару. Это требуется, когда один агент находится за <code>Address Dependent Mapping</code>, что приводит к созданию <code>Peer Reflexive Candidate</code>.</p><p>Каждая <code>Candidate Pair</code> (пара кандидатов), которая &quot;видит&quot; трафик, становится парой <code>Valid Candidate</code> (валидных кандидатов). Управляющий агент берет одного <code>Valid Candidate</code> и выдвигает (nominate) его. Выдвинутые сторонами кандидаты становятся <code>Nominated Pair</code> (номинированной парой). Агенты снова пытаются установить двунаправленную коммуникацию. При достижении успеха, <code>Nominated Pair</code> становится <code>Selected Candidate Pair</code> (выбранной или избранной парой кандидатов). Эта пара используется на протяжении оставшейся части сессии.</p><h4 id="перезагрузка" tabindex="-1">Перезагрузка <a class="header-anchor" href="#перезагрузка" aria-label="Permalink to “Перезагрузка”">​</a></h4><p>Если <code>Selected Candidate Pair</code> прекращает работу по какой-либо причине (истек срок жизни отображения <code>NAT</code>, упал сервер <code>TURN</code>) агент <code>ICE</code> переходит в состояние <code>Failed</code>. Оба агента могут быть перезапущены, и процесс начнется сначала.</p><h2 id="безопасность" tabindex="-1">Безопасность <a class="header-anchor" href="#безопасность" aria-label="Permalink to “Безопасность”">​</a></h2><p>Каждое соединение <code>WebRTC</code> аутентифицируется и шифруется. Это позволяет быть уверенным в том, что третья сторона не видит того, что мы отправляем, и не может добавлять (вставлять) фиктивные сообщения. Также можно быть уверенным, что агент, генерирующий описание сессии - это действительно тот, с кем мы хотим общаться.</p><p>Очень важно, чтобы никто не мог подменять сообщения. Не страшно, если третья сторона прочитает описание сессии во время передачи. Однако, <code>WebRTC</code> не предоставляет защиты от ее модификации. Злоумышленник может осуществить атаку <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%B0%D0%BA%D0%B0_%D0%BF%D0%BE%D1%81%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA%D0%B0" target="_blank" rel="noreferrer">&quot;человек посередине&quot;</a> (атака посредника) путем подмены кандидатов <code>ICE</code> и обновления отпечатка сертификата.</p><h3 id="как-это-работает-2" tabindex="-1">Как это работает? <a class="header-anchor" href="#как-это-работает-2" aria-label="Permalink to “Как это работает?”">​</a></h3><p>Для обеспечения безопасности соединения <code>WebRTC</code> использует 2 существующих протокола: <code>DTLS</code> и <code>SRTP</code>.</p><p><code>DTLS</code> позволяет выполнять подготовку сессии и безопасно обмениваться данными между пирами. Он похож на <code>TLS</code>, который используется в <code>HTTPS</code>, но в качестве протокола транспортного уровня <code>DTLS</code> использует <code>UDP</code> вместо <code>TCP</code>. Это означает, что <code>DTLS</code> не гарантирует надежную доставку сообщений. <code>SRTP</code> был специально разработан для безопасного обмена медиаданными. Он предоставляет несколько оптимизаций по сравнению с <code>DTLS</code>.</p><p>Сначала используется <code>DTLS</code>. Он выполняет рукопожатие через соединение <code>ICE</code>. <code>DTLS</code> - это клиент-серверный протокол, поэтому одна из сторон должна инициировать рукопожатие. Роли &quot;клиент/сервер&quot; определяются в процессе сигнализации. В ходе рукопожатия <code>DTLS</code> каждая сторона генерирует сертификат. После завершения рукопожатия каждый сертификат сравнивается с его хешем, содержащимся в описании сессии. Это позволяет убедиться в том, что рукопожатие произошло с ожидаемым агентом. Затем соединение <code>DTLS</code> может использоваться для коммуникации с помощью <code>DataChannel</code>.</p><p>Для создания сессии <code>SRTP</code> мы инициализируем ее с помощью ключей, сгенерированных <code>DTLS</code>. <code>SRTP</code> не предоставляет механизма рукопожатия, поэтому подготовка соединения осуществляется с помощью внешних ключей. После установки <code>SRTP-соединения</code> стороны могут обмениваться зашифрованными медиаданными.</p><h3 id="security-101" tabindex="-1">Security 101 <a class="header-anchor" href="#security-101" aria-label="Permalink to “Security 101”">​</a></h3><p>Давайте познакомимся с терминами, употребляемыми в криптографии.</p><p><strong>Обычный текст и зашифрованный текст</strong></p><p>Обычный текст (plaintext) - это входные данные для шифрования. Зашифрованный текст (ciphertext) - это результат шифрования.</p><p><strong>Шифрование</strong></p><p><a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80" target="_blank" rel="noreferrer">Шифрование</a> (шифр, cipher) - это последовательность операций по преобразованию обычного текста в зашифрованный. Шифр может быть сохранен для последующей расшифровки зашифрованного текста. Как правило, шифр имеет ключ, меняющий его поведение. Данный процесс также называется encrypting (шифрование) и decrypting (расшифровка).</p><p>Примером простого шифра является <a href="https://ru.wikipedia.org/wiki/ROT13" target="_blank" rel="noreferrer">ROT13</a>. Каждая буква исходного текста сдвигается на <code>13</code> символов вперед. Для расшифровки каждая буква сдвигается на <code>13</code> символов назад. Обычный текст <code>HELLO</code> становится зашифрованным текстом <code>URYYB</code>. В данном случае шифр - это <code>ROT</code>, а ключ - <code>13</code>.</p><p><strong>Хеш-функции</strong></p><p><a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" target="_blank" rel="noreferrer">Хеш-функция</a> (hash function) - это необратимый (однонаправленный) процесс преобразования входных данных в хеш (digest - фарш, мешанина). Для одних и тех же входных данных всегда получается одинаковый результат. Важно, чтобы результат был необратимым. Результат не должен позволять определить входные данные. Хеширование позволяет убедиться в том, что сообщение не было подменено.</p><p>Простой функцией хеширования будет функция, пропускающая каждую вторую букву. <code>HELLO</code> станет <code>HLO</code>. Мы не можем &quot;вернуться&quot; к <code>HELLO</code>, но мы можем убедиться, что <code>HELLO</code> совпадает с хешем.</p><p><strong>Публичные и приватные ключи</strong></p><p>Криптография на основе публичного/приватного ключей (public/private key) описывает тип шифрования, используемого <code>DTLS</code> и <code>SRTP</code>. В такой системе у нас имеется два ключа: публичный (открытый) и приватный (закрытый). Публичный ключ используется для шифрования и его можно передавать другим лицам. Приватный ключ используется для расшифровки и должен быть известен только нам. Расшифровать зашифрованное сообщение можно только с помощью соответствующего приватного ключа.</p><p><strong>Протокол Диффи-Хеллмана</strong></p><p><a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%94%D0%B8%D1%84%D1%84%D0%B8_%E2%80%94_%D0%A5%D0%B5%D0%BB%D0%BB%D0%BC%D0%B0%D0%BD%D0%B0" target="_blank" rel="noreferrer">Протокол Диффи — Хеллмана</a> (Diffie–Hellman Protocol) позволяет двум пользователям, которые никогда не встречались, безопасно создавать общие секреты через Интернет. Пользователь <code>A</code> может отправлять секреты пользователю <code>B</code>, не опасаясь прослушки (eavesdropping). Это зависит от сложности решения проблемы <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%B5_%D0%BB%D0%BE%D0%B3%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" target="_blank" rel="noreferrer">дискретного логарифмирования</a>. Это делает возможным рукопожатие <code>DTLS</code>.</p><p><strong>Псевдослучайная функция</strong></p><p>Псевдослучайная функция (Pseudorandom Function, PRF) - предварительно определенная функция, генерирующая значения, которые на первый взгляд кажутся случайными. Она может принимать несколько входных значений и генерировать один результат.</p><p><strong>Функция формирования ключа</strong></p><p><a href="https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BA%D0%BB%D1%8E%D1%87%D0%B0" target="_blank" rel="noreferrer">Формирование (деривация) ключа</a> (key derivation) - это разновидность псевдослучайной функции. Данная функция используется для усиления ключа. Одним из наиболее распространенных паттернов является <a href="https://en.wikipedia.org/wiki/Key_stretching" target="_blank" rel="noreferrer">растяжка (растяжение) ключа</a> (key stretching).</p><p>Предположим, что у нас имеется ключ размером 8 байтов. Мы можем использовать <code>KDF</code> для того, чтобы сделать его сильнее (длиннее).</p><p><strong>Однократно используемое число</strong></p><p><a href="https://ru.wikipedia.org/wiki/Nonce" target="_blank" rel="noreferrer">Однократно используемое число</a> (nonce) - это дополнительные входные данные для шифрования. Оно используется для получения разных результатов при шифровании одного и того же сообщения. Для каждого сообщения используется уникальный <code>nonce</code>.</p><p><strong>Код аутентификации сообщения</strong></p><p>Код аутентификации сообщения (message authentication code) - это хеш, помещаемый в конец сообщения. <code>MAC</code> позволяет идентифицировать источник сообщения.</p><p><strong>Ротация ключей</strong></p><p>Ротация ключей (key rotation) - это практика периодической замены ключей. Это позволяет снизить ущерб от возможной кражи (утечки) ключа, т.е. добиться того, что украденный или раскрытый другим способом ключ может использоваться для расшифровки лишь ограниченного количества сообщений.</p><h3 id="dtls" tabindex="-1">DTLS <a class="header-anchor" href="#dtls" aria-label="Permalink to “DTLS”">​</a></h3><p><code>DTLS</code> позволяет двум пирам устанавливать безопасное соединение без предварительной настройки. Даже если кто-то будет прослушивать соединение, он не сможет расшифровать сообщения.</p><p>Для того, чтобы коммуникация между клиентом и сервером <code>DTLS</code>, стало возможной, они должны прийти к соглашению о шифре и ключе. Эти значения определяются в процессе рукопожатия. В ходе рукопожатия сообщения представлены в виде обычного текста. После того, как клиент или сервер обменяются достаточным количеством информации для начала шифрования, отправляется <code>Change Cipher Spec</code>. После этого все последующие сообщения подвергаются шифрованию.</p><h4 id="формат-пакета" tabindex="-1">Формат пакета <a class="header-anchor" href="#формат-пакета" aria-label="Permalink to “Формат пакета”">​</a></h4><p>Каждый пакет <code>DTLS</code> начинается с заголовка.</p><p><strong>Тип содержимого</strong></p><p>Тип содержимого (content type) может быть одним из:</p><ul><li><code>20</code> - <code>Change Chipher Spec</code>;</li><li><code>22</code> - рукопожатие (Handshake);</li><li><code>23</code> - данные приложения (Application Data).</li></ul><p><code>Handshake</code> используется для обмена информацией, необходимой для начала сессии. <code>Change Chipher Spec</code> используется для уведомления другой стороны о начале шифрования сообщений. <code>Application Data</code> - это сами зашифрованные сообщения.</p><p><strong>Версия</strong></p><p>Версия (version) может иметь значение <code>0x0000feff</code> (для <code>DTLS v1.0</code>) или <code>0x0000fefd</code> (для <code>DTLS v1.2</code>). Версии 1.1 не существует.</p><p><strong>Эпоха</strong></p><p>Эпоха (epoch) начинается с <code>0</code> и принимает значение <code>1</code> после <code>Change Chipher Spec</code>. Любые сообщения с &quot;ненулевой эпохой&quot; зашифровываются.</p><p><strong>Последовательный номер</strong></p><p>Последовательный номер (sequence number) используется для сохранения порядка сообщений. При каждой отправке сообщения данный номер увеличивается. При увеличении эпохи, данный номер обнуляется.</p><p><strong>Длина сообщения и полезная нагрузка</strong></p><p>Полезная нагрузка (payload) - это конкретный тип содержимого. Для <code>Application Data</code> полезной нагрузкой являются зашифрованные данные. Для <code>Handshake</code> полезная нагрузка зависит от вида сообщения. Длина сообщения (length) определяет размер полезной нагрузки.</p><h4 id="рукопожатие" tabindex="-1">Рукопожатие <a class="header-anchor" href="#рукопожатие" aria-label="Permalink to “Рукопожатие”">​</a></h4><p>В процессе рукопожатия клиент и сервер обмениваются серией сообщений. Эти сообщения группируются в пакеты (flights). Каждый пакет может содержать несколько сообщений или только одно. Пакет считается полученным только после доставки всех содержащихся в нем сообщений. Далее мы рассмотрим назначение каждого сообщения.</p><img src="https://habrastorage.org/webt/7x/ol/qn/7xolqn1dp4518tdgbqyytiwct04.png" alt=""><br><p><strong>ClientHello</strong></p><p><code>ClientHello</code> - это начальное сообщение от клиента. Оно содержит перечень атрибутов. Эти атрибуты сообщают серверу шифр и возможности, поддерживаемые клиентом. Данный шифр также используется в качестве шифра <code>SCTP</code>. <code>ClientHello</code> также содержит случайные данные, которые впоследствии используются для генерации ключей сессии.</p><p><strong>HelloVerifyRequest</strong></p><p><code>HelloVerifyRequest</code> - это сообщение от сервера клиенту. Оно позволяет убедиться, что клиент действительно имел намерение отправить <code>ClientHello</code>. После этого клиент снова отправляет <code>ClientHello</code>, но уже с токеном из <code>HelloVerifyRequest</code>.</p><p><strong>ServerHello</strong></p><p><code>ServerHello</code> - это ответ сервера с настройками сессии. Он содержит шифр и случайные данные.</p><p><strong>Certificate</strong></p><p><code>Certificate</code> содержит сертификат для клиента или сервера. Сертификат используется для идентификации другой стороны коммуникации. После окончания рукопожатия мы проверяем, что хеш сертификата совпадает с его отпечатком в <code>SessionDescription</code>.</p><p><strong>ServerKeyExchange/ClientKeyExchange</strong></p><p>Эти сообщения используются для передачи публичного ключа. При инициализации клиент и сервер генерируют пару ключей. После рукопожатия эти значения используются для генерации <code>Pre-Master Secret</code>.</p><p><strong>CertificateRequest</strong></p><p><code>CertificateRequest</code> - сообщение от сервера клиенту о желании первого получить сертификат. Сервер может просить (request) или требовать (require) получение сертификата.</p><p><strong>ServerHelloDone</strong></p><p><code>ServerHelloDone</code> уведомляет клиента о завершении рукопожатия сервером.</p><p><strong>CertificateVerify</strong></p><p><code>CertificateVerify</code> - так отправитель подтверждает наличие у него приватного ключа из сообщения с сертификатом.</p><p><strong>ChangeCipherSpec</strong></p><p><code>ChangeCipherSpec</code> информирует получателя о том, что последующие сообщения будут зашифрованными.</p><p><strong>Finished</strong></p><p><code>Finished</code> является зашифрованным и содержит хеш всех предыдущих сообщений. Это позволяет убедиться в отсутствии модификации рукопожатия.</p><h4 id="генерация-ключеи" tabindex="-1">Генерация ключей <a class="header-anchor" href="#генерация-ключеи" aria-label="Permalink to “Генерация ключей”">​</a></h4><p>После завершения рукопожатия мы можем отправлять зашифрованные данные. Шифр выбирается сервером и содержится в его <code>ServerHello</code>. Но как выбирается ключ?</p><p>Сначала мы генерируем <code>Pre-Master Secret</code>. Для получения этого значения используется протокол Диффи-Хелмана для ключей, обмениваемых с помощью <code>ServerKeyExchange</code> и <code>ClientKeyExchange</code>. Детали зависят от выбранного шифра.</p><p>Затем генерируется <code>Master Secret</code>. Каждая версия <code>DTLS</code> имеет определенную псевдослучайную функцию. Для <code>DTLS v1.2</code> функция &quot;берет&quot; <code>Pre-Master Secret</code> и случайные значения из <code>ClientHello</code> и <code>ServerHello</code>. Результатом выполнения псевдослучайной функции является <code>Master Secret</code>. <code>Master Secret</code> - это значение, которое используется для шифра.</p><h4 id="обмен-данными" tabindex="-1">Обмен данными <a class="header-anchor" href="#обмен-данными" aria-label="Permalink to “Обмен данными”">​</a></h4><p>Рабочей лошадкой <code>DTLS</code> является <code>ApplicationData</code>. После получения инициализированного шифра мы можем шифровать и передавать сообщения.</p><p>Сообщения <code>ApplicationData</code> используют заголовок <code>DTLS</code>, как описывалось ранее. <code>Payload</code> заполняется зашифрованным текстом. Теперь у нас имеется сессия <code>DTLS</code> и мы можем общаться безопасно.</p><h3 id="srtp" tabindex="-1">SRTP <a class="header-anchor" href="#srtp" aria-label="Permalink to “SRTP”">​</a></h3><p><code>SRTP</code> - это протокол, разработанный специально для шифрования пакетов <code>RTP</code>. Для начала сессии <code>SRTP</code> необходимо определить ключи и шифр. В отличии от <code>DTLS</code> здесь у нас нет механизма рукопожатия. Все настройки и ключи генерируются в ходе рукопожатия <code>DTLS</code>.</p><p><code>DTLS</code> предоставляет отдельный <code>API</code> для экспорта ключей с целью их использования в других процессах. Данный <code>API</code> определяется в <a href="https://datatracker.ietf.org/doc/html/rfc5705" target="_blank" rel="noreferrer">RFC 5705</a>.</p><h4 id="создание-сессии" tabindex="-1">Создание сессии <a class="header-anchor" href="#создание-сессии" aria-label="Permalink to “Создание сессии”">​</a></h4><p><code>SRTP</code> определяет функцию деривации ключей, которая применяется в отношении входных данных. При создании сессии <code>SRTP</code> входные данные пропускаются через эту функцию для генерации ключей для шифра <code>SRTP</code>. После этого можно переходить к обработке данных.</p><h4 id="обмен-медиаданными" tabindex="-1">Обмен медиаданными <a class="header-anchor" href="#обмен-медиаданными" aria-label="Permalink to “Обмен медиаданными”">​</a></h4><p>Каждый пакет <code>RTP</code> имеет 16-битный <code>SequenceNumber</code> (последовательный номер). Этот номер используется для сохранения правильного порядка доставки пакетов (последовательные номера напоминают первичные ключи - primary keys). В ходе сессии этот номер автоматически увеличивается. Для этого используется специальный счетчик (rollover counter).</p><p>При шифровании пакета <code>SRTP</code> использует счетчик и последовательный номер в качестве одноразового значения (nonce). Это позволяет добиться того, что даже при повторной отправке сообщения, его зашифрованный текст будет разным. Это защищает от идентификации паттерна атакующим, а также от выполнения повторной атаки.</p><h2 id="коммуникация-в-реальном-времени" tabindex="-1">Коммуникация в реальном времени <a class="header-anchor" href="#коммуникация-в-реальном-времени" aria-label="Permalink to “Коммуникация в реальном времени”">​</a></h2><p>Сети - это ограничительный фактор для коммуникации в реальном времени. В идеальном мире размер передаваемых данных неограничен и пакеты доставляются мгновенно. В реальном мире это не так. Возможности сетей являются ограниченными, условия могут измениться в любое время. Измерение и мониторинг сетей также представляет собой сложную задачу. Мы получаем разное поведение в зависимости от &quot;железа&quot;, программного обеспечения и их настроек.</p><p>В случае с коммуникацией в реальном времени существует еще одна проблема, которой нет в других средах. Для разработчика медленная работа сайта в некоторых сетях не является серьезной проблемой. До тех пор, пока все данные приходят, пользователи счастливы. Однако в <code>WebRTC</code> &quot;старые&quot; данные являются бесполезными. Никого не интересует, что было сказано на конференции пять секунд назад. Поэтому при разработке систем, работающих в режиме рального времени, зачастую приходится выбирать между задержкой в передаче и размером передаваемых данных.</p><h3 id="какие-атрибуты-делают-сети-сложными" tabindex="-1">Какие атрибуты делают сети сложными? <a class="header-anchor" href="#какие-атрибуты-делают-сети-сложными" aria-label="Permalink to “Какие атрибуты делают сети сложными?”">​</a></h3><p>Код, который эффективно работает во всех сетях, является сложным. Необходимо учитывать множество разных факторов, которые могут неочевидным образом влиять друг на друга. Ниже представлен список наиболее общих задач, с решением которых сталкиваются разработчики.</p><p><strong>Пропускная способность</strong></p><p>Пропускная способность (bandwidth) - это количество данных, которые можно передать по сети. Важно понимать, что данная величина не является постоянной. Пропускная способность зависит от нагрузки, т.е. от количества людей, использующих этот маршрут (роут).</p><p><strong>Время передачи и время в пути туда и обратно</strong></p><p>Время передачи (transmission time) - это время достижения пакетом пункта назначения. Как и пропускная способность, это значение не является константным. Время передачи может меняться в ходе сессии.</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">transmission_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = receive_time - send_time</span></span></code></pre></div><p>Для расчета время передачи нам нужны часы на стороне отправителя и получателя, синхронизированные с точностью до миллисекунд. Даже небольшая разница может привести к ненадежному измерению времени. Поскольку <code>WebRTC</code> функционирует в высокогетерогенных средах, достижение совершенной синхронизации между хостами является почти невозможным.</p><p>Время туда и обратно (round trip time) - это попытка решения проблемы синхронизации.</p><p>Вместо использования распределенных часов пир <code>WebRTC</code> отправляет специальный пакет, содержащий время в <code>sendertime1</code>. Второй пир получает пакет, фиксирует время и отправляет пакет обратно. После получения пакета отправителем, он вычитает время, записанное в <code>sendertime1</code>, из текущего времени <code>sendertime2</code>. Эта разница во времени называется временем в пути туда и обратно.</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rtt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = sendertime2 - sendertime1</span></span></code></pre></div><p>Половина времени туда и обратно считается хорошим приближением времени передачи. Этот подход имеет некоторые недостатки. При его использовании мы исходим из предположения, что отправка и получение пакета занимают равное время. Однако в сотовых сетях операции по отправке и получению могут быть несимметричными по времени. Вы могли замечать, что скорость передачи данных на телефоне почти всегда меньше скорости загрузки данных.</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">transmission_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = rtt/2</span></span></code></pre></div><p>Технические детали измерения времени туда и обратно подробно описаны в следующем разделе.</p><p><strong>Джиттер</strong></p><p>Причиной <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B6%D0%B8%D1%82%D1%82%D0%B5%D1%80" target="_blank" rel="noreferrer">джиттера</a> (jitter) является разное время передачи пакетов. Пакеты могут запаздывать и прибывать группами.</p><p><strong>Потеря пакетов</strong></p><p>Потеря пакетов (packets loss) - это когда сообщения теряются при передаче, т.е. не доходят до адресата. Потеря может быть постоянной или случайной. Это может быть связано с типом сети, например, спутниковая или <code>Wi-Fi</code>. Это также может быть связано с ПО, встретившимся на пути сообщения.</p><p><strong>Максимальная единица передачи</strong></p><p>Максимальная единица передачи (maximum transmission unit) - это максимальный размер единичного пакета. Сети не позволяют отправлять одно гигантское сообщение. На уровне протокола сообщения разбиваются (split) на более мелкие пакеты.</p><p><code>MTU</code> также различается в зависимости от выбранного маршрута. Для определения <code>MTU</code> можно использовать протокол <a href="https://datatracker.ietf.org/doc/html/rfc1191" target="_blank" rel="noreferrer">Исследования MTU по пути</a>.</p><h4 id="перегрузка" tabindex="-1">Перегрузка <a class="header-anchor" href="#перегрузка" aria-label="Permalink to “Перегрузка”">​</a></h4><p>Перегрузка (congestion) возникает при достижении лимитов сети. Обычно, это связано с достижением предельной пропускной способности текущего роута. Или это может быть связано с временными ограничениями, накладываемыми вашим Интернет-провайдером.</p><p>Перегрузка проявляется по-разному. Не существует стандартного поведения. В большинстве случаев при возникновении перегрузки лишние пакеты начинают игнорироваться. В других случаях происходит <a href="https://ru.wikipedia.org/wiki/%D0%91%D1%83%D1%84%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)" target="_blank" rel="noreferrer">буферизация</a>. Это приводит к увеличению времени передачи. В перегруженных сетях также можно наблюдать усиление джиттера. Все, о чем мы тут говорим, – быстро развивающаяся сфера и в ней продолжают появляться новые алгоритмы для определения перегрузки.</p><h4 id="динамичность" tabindex="-1">Динамичность <a class="header-anchor" href="#динамичность" aria-label="Permalink to “Динамичность”">​</a></h4><p>Сети являются невероятно динамичными, их условия меняются очень быстро. Во время звонка мы можем отправлять и получать сотни тысяч пакетов. Эти пакеты будут проходить через несколько переходов (посредников, ретрансляторов) (hops). Эти переходы будут распределены между миллионами других пользователей. Даже в локальной сети мы можем загружать фильм в формате <code>HD</code> или наше устройство может загружать обновление во время звонка.</p><p>Поддержка стабильности звонка является не такой простой задачей, как исследование сети при инициализации. Необходимо проводить постоянные вычисления. Также необходимо учитывать все факторы, на которые оказывают влияние сетевое &quot;железо&quot; и ПО.</p><h3 id="решение-проблемы-потери-данных" tabindex="-1">Решение проблемы потери данных <a class="header-anchor" href="#решение-проблемы-потери-данных" aria-label="Permalink to “Решение проблемы потери данных”">​</a></h3><p>Потеря пакетов - это первая задача, которую необходимо решить при разработке системы коммуникации в реальном времени. Существует множество способов это сделать, каждый со своими плюсами и минусами. Это зависит от того, что мы отправляем и насколько критичной является задержка. Также следует отметить, что не всякая потеря является фатальной. Потеря незначительного количества видеоданных будет незаметна для человеческого глаза. Однако потеря текста сообщения является фатальной.</p><p>Предположим, что мы отправили 10 пакетов и пакеты 5 и 6 были потеряны. Давайте разберем, как можно решить эту проблему.</p><h4 id="acknowledgments" tabindex="-1">Acknowledgments <a class="header-anchor" href="#acknowledgments" aria-label="Permalink to “Acknowledgments”">​</a></h4><p>Acknowledgments (подтверждения) - это способ, которым получатель сообщает отправителю о получении каждого пакета. Отправитель узнает о потере пакета при получении повторного подтверждения о пакете, который не является последним. Когда отправитель получает <code>ACK</code> для пакета 4 дважды, он понимает, что пакет 5 был потерян.</p><h4 id="selective-acknowledgments" tabindex="-1">Selective Acknowledgments <a class="header-anchor" href="#selective-acknowledgments" aria-label="Permalink to “Selective Acknowledgments”">​</a></h4><p>Selective Acknowledgments (выборочные подтверждения) - это улучшение обычных подтверждений. Получатель может отправить <code>SACK</code> с подтверждениями для нескольких пакетов и таким образом уведомить отправителя о потере пакетов. Отправитель получает <code>SACK</code> для пакетов 4 и 7 и понимает, что пакеты 5 и 6 были потеряны. В ответ он повторно отправляет потерянные пакеты.</p><h4 id="negative-acknowledgments" tabindex="-1">Negative Acknowledgments <a class="header-anchor" href="#negative-acknowledgments" aria-label="Permalink to “Negative Acknowledgments”">​</a></h4><p>Negative Acknowledgments (негативные подтверждения) решают проблему противоположным образом. Вместо уведомления отправителя о полученном, получатель уведомляет его о том, что было потеряно. В нашем случае <code>NACK</code> отправляется для пакетов 5 и 6. Отправитель знает только о пакетах, которые необходимо отправить повторно.</p><h4 id="forward-error-correction" tabindex="-1">Forward Error Correction <a class="header-anchor" href="#forward-error-correction" aria-label="Permalink to “Forward Error Correction”">​</a></h4><p>Forward Error Correction (превентивное исправление ошибок) пытается решить проблему потери данных заблаговременно. Отправитель отправляет дополнительные данных, чтобы потеря пакетов не повлияла на результат. Одним из примеров <code>FEC</code> является <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%A0%D0%B8%D0%B4%D0%B0_%E2%80%94_%D0%A1%D0%BE%D0%BB%D0%BE%D0%BC%D0%BE%D0%BD%D0%B0" target="_blank" rel="noreferrer">код Рида-Соломона</a>.</p><p>Это уменьшает задержку/сложность отправки и получения подтверждений. <code>FEC</code> является пустой тратой полосы пропускания в случае, если потеря данных в сети близка к нулю.</p><h3 id="решение-проблемы-джиттера" tabindex="-1">Решение проблемы джиттера <a class="header-anchor" href="#решение-проблемы-джиттера" aria-label="Permalink to “Решение проблемы джиттера”">​</a></h3><p>Джиттер присутствует в большинстве сетей. Даже внутри <code>LAN</code> у нас много устройств, отправляющих данные с разной скоростью. Вы можете легко увидеть джиттер, &quot;пропинговав&quot; (pinging) другое устройство с помощью команды <code>ping</code>, и наблюдая за флуктуациями, происходящими во время пути туда и обратно (<code>rtt</code>).</p><p>Для преодоления джиттера клиенты используют <code>JitterBuffer</code>. Он обеспечивает постоянную скорость доставки пакетов. Недостатком является задержка, которую <code>JitterBuffer</code> добавляет к пакетам, которые прибыли слишком рано. А его преимущество в том, что опоздавшие пакеты не вызывают джиттер. Представьте, что в течение звонка вы видите такое время прибытия пакетов:</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.46 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.93 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.57 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.55 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.54 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.72 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.45 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.73 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">* </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=1.80 ms</span></span></code></pre></div><p>В данном случае хорошим выбором будет <code>1,8 мс</code>. Пакеты, которые будут прибывать позднее, смогут использовать наше окно задержки или временной зазор (window of latency). Пакеты, прибывающие рано, будут немного задержаны и затем помещены в окно вместе с опоздавшими пакетами. Это означает, что мы избавляемся от дрожания и обеспечиваем плавную доставку сообщений клиенту.</p><p><strong>Операция JitterBuffer</strong></p><img src="https://habrastorage.org/webt/w4/7x/4u/w47x4uy--zce307iuqsmfp1u97s.png" alt=""><br><p>Каждый пакет помещается в буфер при получении. Когда пакетов становится достаточно для реконструкции фрейма (кадра), фрейм высвобождается (release) из буфера и отправляется на расшифровку (decoding). Декодер, в свою очередь, расшифровывает и отрисовывает видеофрейм на экране пользователя. Поскольку буфер имеет ограниченную вместимость, пакеты, которые находятся там слишком долго, отклоняются (discarded).</p><p><code>jitterBufferDelay</code> предоставляет хорошие данные о производительности сети и ее влиянии на плавность воспроизведения. <code>jitterBufferDelay</code> является частью <a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferdelay" target="_blank" rel="noreferrer"><code>WebRTC statictics API</code></a>, относящейся к входящему потоку получателя. Задержка (delay) определяет время, которое видеофреймы проводят в буфере перед отправкой декодеру. Большая задержка означает, что наша сеть сильно нагружена.</p><h3 id="определение-перегрузки" tabindex="-1">Определение перегрузки <a class="header-anchor" href="#определение-перегрузки" aria-label="Permalink to “Определение перегрузки”">​</a></h3><p>Перед решением проблемы перегрузки сети, необходимо эту перегрузку определить. Для этого используется congestion controller (контроллер перегрузки). Это сложная вещь, которая в настоящее время активно развивается. Все время публикуются и тестируются новые алгоритмы. На самом высоком уровне все они делают одно и то же. Контроллер перегрузки выполняет оценку пропускной способности на основе некоторых входных данных, например:</p><ul><li>потеря пакетов - потеря пакетов в перегруженных сетях увеличивается;</li><li>джиттер - по мере увеличения нагрузки время доставки пакетов становится все более нестабильным;</li><li>время туда и обратно - время туда и обратно при высокой нагрузке увеличивается;</li><li>явные уведомления о перегрузке (explicit congestion notification) - новейшие сети могут помечать пакеты как находящиеся под угрозой потери для уменьшения нагрузки.</li></ul><p>В процессе звонка эти значения должны все время измеряться. Использование сети может увеличиваться и уменьшаться, следовательно, будет меняться пропускная способность.</p><h3 id="решение-проблемы-перегрузки" tabindex="-1">Решение проблемы перегрузки <a class="header-anchor" href="#решение-проблемы-перегрузки" aria-label="Permalink to “Решение проблемы перегрузки”">​</a></h3><p>После измерения пропускной способности нам необходимо настроить то, что мы отправляем. Настройки зависят от типа передаваемых данных.</p><h4 id="снижение-скорости-передачи-данных" tabindex="-1">Снижение скорости передачи данных <a class="header-anchor" href="#снижение-скорости-передачи-данных" aria-label="Permalink to “Снижение скорости передачи данных”">​</a></h4><p>Ограничение скорости передачи данных - первое решение проблемы перегрузки. Контроллер нагрузки предоставляет расчеты, а отправитель ограничивает скорость.</p><p>В большинстве случаев используется именно этот способ. В случае с <code>TCP</code> это берет на себя операционная система, процесс является полностью прозрачным для пользователей и разработчиков.</p><h4 id="уменьшение-количества-передаваемых-данных" tabindex="-1">Уменьшение количества передаваемых данных <a class="header-anchor" href="#уменьшение-количества-передаваемых-данных" aria-label="Permalink to “Уменьшение количества передаваемых данных”">​</a></h4><p>В некоторых случаях мы можем отправлять меньшее количество информации для удовлетворения лимитов. В <code>WebRTC</code> мы не можем снижать скорость передачи данных.</p><p>Если нам не хватает пропускной способности, мы можем, например, снизить качество передаваемого видео. Для этого требуется тесная связь между видеокодером и контроллером перегрузок.</p><h2 id="обмен-медиаданными-1" tabindex="-1">Обмен медиаданными <a class="header-anchor" href="#обмен-медиаданными-1" aria-label="Permalink to “Обмен медиаданными”">​</a></h2><p><code>WebRTC</code> позволяет отправлять и получать неограниченное количество аудио и видеопотоков. Мы можем добавлять и удалять эти потоки в любое время в течение сессии. Потоки могут быть автономными или объединяться в один. Мы можем отправлять видео захвата экрана и добавлять к нему аудио и видео из вебкамеры.</p><p>Протокол <code>WebRTC</code> не зависит от кодеков. Лежащий в его основе транспорт поддерживает все, даже то, чего еще не существует. Однако агент, с которым мы общаемся, может не иметь инструментов, необходимых для принятия звонка.</p><p><code>WebRTC</code> спроектирован для работы в динамичных условиях сетей. Во время звонка пропускная способность может увеличиваться и уменьшаться. Мы можем внезапно столкнуться с сильной потерей пакетов. Протокол предоставляет возможности для решения этой проблемы. <code>WebRTC</code> реагирует на изменение условий сети и старается обеспечить наилучший опыт использования с учетом доступных ресурсов.</p><h3 id="как-это-работает-3" tabindex="-1">Как это работает? <a class="header-anchor" href="#как-это-работает-3" aria-label="Permalink to “Как это работает?”">​</a></h3><p><code>WebRTC</code> использует 2 протокола, <code>RTP</code> и <code>RTCP</code>, определенные в <a href="https://tools.ietf.org/html/rfc1889" target="_blank" rel="noreferrer">RFC 1889</a>.</p><p><code>RTP</code> - это протокол для передачи медиаданных. Он был разработан для передачи видео в реальном времени. Он не устанавливает никаких правил относительно задержки или надежности доставки пакетов, но предоставляет инструменты для их настройки. <code>RTP</code> предоставляет потоки, которые могут передаваться через одно соединение. Он также предоставляет информацию о времени отправки и порядке пакетов, необходимую для правильного формирования медиаконвейера (media pipeline).</p><p><code>RTCP</code> - это протокол, содержащий метаданные о звонке. Формат протокола является очень гибким и позволяет добавлять любые метаданные. Это используется для сбора статистики о звонке. Также это может использоваться для обработки потери пакетов и реализации контроля перегрузки. Он предоставляет двунаправленную коммуникацию, автоматически адаптирующуюся к постоянно меняющимся сетевым условиям.</p><h3 id="задержка-против-качества" tabindex="-1">Задержка против качества <a class="header-anchor" href="#задержка-против-качества" aria-label="Permalink to “Задержка против качества”">​</a></h3><p>Обмен медиаданными в реальном времени всегда сопряжен с выбором между задержкой и качеством. Чем большую задержку мы можем себе позволить, тем выше будет качество медиа.</p><h4 id="ограничения-реального-мира-1" tabindex="-1">Ограничения реального мира <a class="header-anchor" href="#ограничения-реального-мира-1" aria-label="Permalink to “Ограничения реального мира”">​</a></h4><p>Это обусловлено ограничениями реального мира - характеристиками сети, которые необходимо учитывать.</p><h4 id="видео-является-сложным" tabindex="-1">Видео является сложным <a class="header-anchor" href="#видео-является-сложным" aria-label="Permalink to “Видео является сложным”">​</a></h4><p>Передача видео - сложный процесс. Для хранения 30-минутного несжатого 720 8-битного видео требуется около 110 Гб. В таких условиях конференция с четырьмя участниками является невозможной. Следовательно, нам нужен какой-то способ уменьшения размера видео и ответом является сжатие (compression). Однако, это имеет некоторые недостатки.</p><h3 id="video-101" tabindex="-1">Video 101 <a class="header-anchor" href="#video-101" aria-label="Permalink to “Video 101”">​</a></h3><p>Мы не будем рассматривать сжатие видео в подробностях. Мы рассмотрим его в степени, достаточной для понимания того, почему <code>RTP</code> спроектирован так, как спроектирован. Сжатие видео - это его кодировка, преобразование в другой формат, который требует меньшего количества битов для представления аналогичного видео.</p><h4 id="сжатие-с-потереи-и-без-потери-качества" tabindex="-1">Сжатие с потерей и без потери качества <a class="header-anchor" href="#сжатие-с-потереи-и-без-потери-качества" aria-label="Permalink to “Сжатие с потерей и без потери качества”">​</a></h4><p>Мы можем кодировать видео без потери (lossless compression) и с потерей (lossy compresion) качества. Поскольку кодировка без потери требует большего количества данных для передачи пиру, увеличивая задержку и потерю пакетов, <code>RTP</code>, как правило, применяет кодировку с потерей, несмотря на то, что это приводит к снижению качества видео.</p><h4 id="внутри-и-межкадровое-сжатие" tabindex="-1">Внутри и межкадровое сжатие <a class="header-anchor" href="#внутри-и-межкадровое-сжатие" aria-label="Permalink to “Внутри и межкадровое сжатие”">​</a></h4><p>Сжатие видео делится на 2 вида. Первый - это сжатие внутри кадра (или просто сжатие кадра, intra-frame compression). Такое сжатие уменьшает количество бит, используемых для описания единичного видеофрейма. Аналогичная техника используется для сжатия неподвижных (still) изображений, например, <code>JPEG</code>.</p><p>Второй тип - это межкадровое сжатие (inter-frame compression). Поскольку видео состоит из большого количества изображений (кадров, фреймов), мы ищем способы не отправлять одинаковую информацию дважды.</p><h4 id="типы-межкадрового-сжатия" tabindex="-1">Типы межкадрового сжатия <a class="header-anchor" href="#типы-межкадрового-сжатия" aria-label="Permalink to “Типы межкадрового сжатия”">​</a></h4><p>Межкадровое сжатие делится на 3 типа:</p><ul><li><strong>I-Frame</strong> - полное изображение, может кодироваться во что угодно;</li><li><strong>P-Frame</strong> - частичное изображение, содержащее только изменения предыдущего изображения;</li><li><strong>B-Frame</strong> - частичное изображение - совмещение предыдущего и будущего изображений.</li></ul><p>Визуализация этих типов:</p><img src="https://habrastorage.org/webt/_p/ap/ca/_papcarjstymqzuquzwolj2lmzi.png" alt=""><br><h4 id="видео-является-деликатным" tabindex="-1">Видео является деликатным <a class="header-anchor" href="#видео-является-деликатным" aria-label="Permalink to “Видео является деликатным”">​</a></h4><p>Сжатие видео очень сильно зависит от его состояния, что делает сложным его передачу по сети. Что случится, если мы потеряем часть <code>I-Frame</code>? Откуда <code>P-Frame</code> знает, что модифицировать? С ростом сложности сжатия, вопросов становится все больше и больше. К счастью, <code>RTP</code> и <code>RTCP</code> предоставляют решение этих проблем.</p><h3 id="rtp" tabindex="-1">RTP <a class="header-anchor" href="#rtp" aria-label="Permalink to “RTP”">​</a></h3><h4 id="формат-пакета-1" tabindex="-1">Формат пакета <a class="header-anchor" href="#формат-пакета-1" aria-label="Permalink to “Формат пакета”">​</a></h4><p>Каждый пакет <code>RTP</code> имеет следующую структуру:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|V=2|P|X|  CC   |M|     PT      |       Sequence Number         |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                           Timestamp                           |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|           Synchronization Source (SSRC) identifier            |</span></span>
<span class="line"><span>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span></span>
<span class="line"><span>|            Contributing Source (CSRC) identifiers             |</span></span>
<span class="line"><span>|                             ....                              |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                            Payload                            |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p><strong>Version (V)</strong></p><p><code>Version</code> (версия) всегда имеет значение <code>2</code>.</p><p><strong>Padding (P)</strong></p><p><code>Padding</code> (заполнение) - логическое значение, определяющее, имеет ли полезная нагрузка заполнение.</p><p>Последний байт полезной нагрузки содержит количество байтов заполнения.</p><p><strong>Extension (X)</strong></p><p>Если установлен, заголовок <code>RTP</code> будет содержать расширения. Мы поговорим об этом позже.</p><p><strong>CSRC count (CC)</strong></p><p>Количество идентификаторов <code>CSRC</code>, следующих после <code>SSRC</code>, но перед полезной нагрузкой.</p><p><strong>Marker (M)</strong></p><p>Бит маркера не имеет предопределенного значения и может использоваться как угодно.</p><p>В некоторых случаях он устанавливается, когда пользователь что-нибудь говорит. Также он часто используется для индикации ключевого кадра (keyframe).</p><p><strong>Payload Type (PT)</strong></p><p><code>Payload Type</code> (тип полезной нагрузки) - это уникальный идентификатор кодека, который используется данным пакетом.</p><p><code>Payload Type</code> является динамическим. <a href="https://ru.wikipedia.org/wiki/VP8" target="_blank" rel="noreferrer"><code>VP8</code></a> в одном звонке может отличаться от <code>VP8</code> в другом звонке. Инициатор звонка (offerer) определяет связь между <code>Payload Types</code> и кодеками в <code>Session Description</code> (описании сессии).</p><p><strong>Sequence Number</strong></p><p><code>Sequence Number</code> (последовательный номер) используется для упорядочивания пакетов в потоке. При каждой отправке пакета <code>Sequence Number</code> увеличивается на единицу.</p><p><code>RTP</code> спроектирован таким образом, что получатель имеет возможность своевременно обнаруживать потерю пакетов.</p><p><strong>Timestamp</strong></p><p>Момент выборки (sampling instant) для данного пакета. Это не глобальные часы, а время, прошедшее с начала передачи потока. Несколько пакетов <code>RTP</code> могут иметь одинаковый <code>Timestamp</code>, если они, например, являются частью одного фрейма.</p><p><strong>Synchronization Source (SSRC)</strong></p><p><code>SSRC</code> (источник синхронизации) - это уникальный идентификатор потока. Это позволяет передавать несколько медиапотоков через одно соединение <code>RTP</code>.</p><p><strong>Contributing Source (CSRC)</strong></p><p><code>CSRC</code> (вспомогательный источник) обычно используется для индикаторов речи. Скажем, на сервере мы объединили несколько аудиопотоков в один <code>RTP-поток</code>. Далее мы используем это поле для определения того, что &quot;входящие потоки A и C в данный момент разговаривают между собой&quot;.</p><p><strong>Payload</strong></p><p><code>Payload</code> - это полезная нагрузка, фактически передаваемые данные.</p><h3 id="rtcp" tabindex="-1">RTCP <a class="header-anchor" href="#rtcp" aria-label="Permalink to “RTCP”">​</a></h3><h4 id="формат-пакета-2" tabindex="-1">Формат пакета <a class="header-anchor" href="#формат-пакета-2" aria-label="Permalink to “Формат пакета”">​</a></h4><p>Каждый пакет <code>RTCP</code> имеет следующую структуру:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|V=2|P|    RC   |       PT      |             length            |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                            Payload                            |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p><strong>Version (V)</strong></p><p><code>Version</code> всегда имеет значение <code>2</code>.</p><p><strong>Padding (P)</strong></p><p>Аналогично <code>RTP</code>.</p><p><strong>Reception Report Count (RC)</strong></p><p>Количество отчетов (reports) в данном пакете. Один пакет <code>RTCP</code> может содержать несколько событий (events).</p><p><strong>Packet Type (PT)</strong></p><p>Уникальный идентификатор типа пакета <code>RTCP</code>. Агент <code>WebRTC</code> не обязан поддерживать все типы, поддержка между агентами может отличаться. На практике можно встретить следующие типы:</p><ul><li><code>192</code> - полный запрос INTRA-frame (<code>FIR</code>);</li><li><code>193</code> - негативные подтверждения (<code>NACK</code>);</li><li><code>200</code> - отчет отправителя (sender report);</li><li><code>201</code> - отчет получателя (receiver report);</li><li><code>205</code> - общая обратная связь (feedback) <code>RTP</code>;</li><li><code>206</code> - обратная связь определенной полезной нагрузки.</li></ul><p>Значимость каждого из этих типов пакетов будет описана ниже.</p><h4 id="полныи-запрос-intra-frame-fir-и-picture-loss-indication-pli" tabindex="-1">Полный запрос INTRA-frame (FIR) и Picture Loss Indication (PLI) <a class="header-anchor" href="#полныи-запрос-intra-frame-fir-и-picture-loss-indication-pli" aria-label="Permalink to “Полный запрос INTRA-frame (FIR) и Picture Loss Indication (PLI)”">​</a></h4><p>Сообщения <code>FIR</code> и <code>PLI</code> (обнаружение потери изображения) служат одной цели. Эти сообщения запрашивают у отправителя полный ключевой кадр. <code>PLI</code> используется, когда декодер получает частичные фреймы и не может их декодировать. Это может произойти из-за потери данных или ошибки декодера.</p><p>Согласно <a href="https://datatracker.ietf.org/doc/html/rfc5104#section-4.3.1.2" target="_blank" rel="noreferrer">RFC 5104</a> <code>FIR</code> не должен использоваться при потере пакетов или фреймов. Это задача <code>PLI</code>. <code>FIR</code> запрашивает ключевой кадр, например, при подключении к сессии нового участника. Для начала декодирования видео требуется ключевой кадр, декодер будет отклонять кадры до его получения.</p><p>Получатель запрашивает полный ключевой кадр сразу после подключения, это позволяет минимизировать задержку между подключением и появлением изображения на экране пользователя.</p><p>Пакеты <code>PLI</code> являются частью сообщений с ответной реакцией на определенную полезную нагрузку.</p><p>На практике ПО, которое умеет работать с пакетами <code>PLI</code> и <code>FIR</code>, используется в обоих случаях. Оно отправляет сигнал кодеру о предоставлении нового полного ключевого кадра.</p><h4 id="негативные-подтверждения" tabindex="-1">Негативные подтверждения <a class="header-anchor" href="#негативные-подтверждения" aria-label="Permalink to “Негативные подтверждения”">​</a></h4><p><code>NACK</code> &quot;просит&quot; отправителя повторить отправку пакета <code>RTP</code>. Обычно, это связано с потерей пакета, но также может быть связано с его задержкой.</p><p><code>NACK</code> является гораздо более эффективным с точки зрения пропускной способности решением, чем запрос всего фрейма. Поскольку <code>RTP</code> разбивает пакеты на части (chunks), запрашивается лишь маленький недостающий кусочек. Получатель создает сообщение с <code>SSRC</code> и последовательным номером. Если отправитель не может повторно отправить запрошенный пакет, он просто игнорирует это сообщение.</p><h4 id="отчеты-отправителя-и-получателя" tabindex="-1">Отчеты отправителя и получателя <a class="header-anchor" href="#отчеты-отправителя-и-получателя" aria-label="Permalink to “Отчеты отправителя и получателя”">​</a></h4><p>Эти отчеты используются для обмена статистикой между агентами. Статистика содержит информацию о количестве полученных пакетов и джиттере.</p><p>Отчеты могут использоваться для диагностики и контроля перегрузки.</p><h3 id="как-rtp-rtcp-решают-проблемы-вместе" tabindex="-1">Как RTP/RTCP решают проблемы вместе? <a class="header-anchor" href="#как-rtp-rtcp-решают-проблемы-вместе" aria-label="Permalink to “Как RTP/RTCP решают проблемы вместе?”">​</a></h3><p><code>RTP</code> и <code>RTCP</code> работают вместе над решением упомянутых выше проблем, связанных с динамичными условиями сетей. Эти техники все еще активно развиваются.</p><h4 id="forward-error-correction-1" tabindex="-1">Forward Error Correction <a class="header-anchor" href="#forward-error-correction-1" aria-label="Permalink to “Forward Error Correction”">​</a></h4><p>Также известное как <code>FEC</code> (превентивное исправление ошибок) - другой способ решения проблемы потери пакетов. <code>FEC</code> - это когда мы отправляем данные несколько раз, без запроса на их повторную отправку. Это происходит на уровне <code>RTP</code> или даже на уровне кодека.</p><p>Если потеря пакетов является постоянной, <code>FEC</code> является более эффективным с точки зрения задержки, чем <code>NACK</code>. Время туда и обратно (round-trip time, rtt) запроса на повторную отправку недостающего пакета и отправку этого пакета может быть значительным в случае с <code>NACK</code>.</p><h4 id="адаптивная-оценка-битреита-и-пропускнои-способности" tabindex="-1">Адаптивная оценка битрейта и пропускной способности <a class="header-anchor" href="#адаптивная-оценка-битреита-и-пропускнои-способности" aria-label="Permalink to “Адаптивная оценка битрейта и пропускной способности”">​</a></h4><p>Как говорилось в предыдущем разделе, сети являются непредсказуемыми и ненадежными. Пропускная способность может меняться несколько раз на протяжении одной сессии. Нередки случаи резкого изменения доступной пропускной способности (на порядки величины) в течение одной секунды.</p><p>Основная идея заключается в том, чтобы настраивать битрейт кодирования на основе прогнозируемой, текущей и будущей пропускной способности сети. Это позволяет обеспечить наилучшее качество передаваемого аудио или видео и избежать разрыва соединения по причине перегрузки. Эвристические техники, моделирующие поведение сети и пытающиеся его предсказать, известны как оценка пропускной способности (bandwidth estimation).</p><p>Здесь существует много нюансов, остановимся на некоторых из них подробнее.</p><h3 id="идентификация-и-передача-состояния-сети" tabindex="-1">Идентификация и передача состояния сети <a class="header-anchor" href="#идентификация-и-передача-состояния-сети" aria-label="Permalink to “Идентификация и передача состояния сети”">​</a></h3><p><code>RTP/RTCP</code> используются в разных сетях, как следствие, иногда происходят обрывы соединения. Будучи построенными поверх <code>UDP</code>, эти протоколы не предоставляют встроенного механизма для повторной передачи пакетов, не говоря уже о контроле перегрузки.</p><p>Для обеспечение наилучшего пользовательского опыта <code>WebRTC</code> должен вычислять качество сетевого маршрута и адаптироваться к его изменениям. Ключевыми факторами мониторинга является следующее: доступная пропускная способность (в каждом направлении, может быть ассиметричной), время туда и обратно и джиттер (флуктуации, возникающие в пути туда и обратно). Это необходимо для расчета потери пакетов и обмена информацией об изменении этих свойств в процессе эволюции сетевых условий.</p><p>Рассматриваемые протоколы преследуют две главные цели:</p><ol><li>Вычисление доступной пропускной способности (в каждом направлении), поддерживаемой сетью.</li><li>Обмен информацией о характеристиках сети между отправителем и получателем.</li></ol><p><code>RTP/RTCP</code> предоставляет три подхода к решению этих задач. Каждый подход имеет свои плюсы и минусы. Применяемый подход зависит от стека ПО, доступного клиентам, а также от библиотек, используемых в приложении.</p><h4 id="отчеты-отправителя-получателя" tabindex="-1">Отчеты отправителя/получателя <a class="header-anchor" href="#отчеты-отправителя-получателя" aria-label="Permalink to “Отчеты отправителя/получателя”">​</a></h4><p>Эти сообщения <code>RTCP</code> определяются в <a href="https://datatracker.ietf.org/doc/html/rfc3550#section-6.4" target="_blank" rel="noreferrer">RFC 3550</a> и используются для обмена характеристиками сети между конечными точками. Отчеты получателя (receiver reports) посвящены качеству сети (включая потерю пакетов, время туда и обратно и джиттер) и используются в алгоритмах, предназначенных для расчета доступной пропускной способности.</p><p>Отчеты отправителя и получателя (sender reports/receiver reports, SR/RR) вместе формируют картину качества сети. Они отправляются для каждого <code>SSRC</code> и являются входными данными для вычисления пропускной способности. Эти вычисления производятся отправителем после получения данных <code>RR</code>, содержащих следующие поля:</p><ul><li><code>Fraction Lost</code> (доля потерянных пакетов) - какой процент пакетов был потерян после последнего <code>RR</code>;</li><li><code>Cumulative Number of Packets Lost</code> (совокупное количество потерянных пакетов) - сколько пакетов было потеряно в течение сессии;</li><li><code>Extended Highest Sequence Number Received</code> (полученный расширенный максимальный последовательный номер) - какой последовательный номер был получен последним, и сколько раз он был получен;</li><li><code>Interarrival Jitter</code> (общий джиттер) - джиттер всего звонка;</li><li><code>Last Sender Report Timestamp</code> (время последнего отчета отправителя) - последнее известное время отправителя, используется для расчета времени туда и обратно.</li></ul><p><code>SR</code> и <code>RR</code> используются для вычисления времени туда и обратно.</p><p>Отправитель включает в <code>SR</code> свое локальное время <code>sendertime1</code>. При получении пакета <code>SR</code> получатель отправляет в ответ <code>RR</code>. Кроме прочего, <code>RR</code> включает в себя <code>sendertime1</code>, полученное от отправителя. Между получением <code>SR</code> и отправкой <code>RR</code> образуется задержка. По этой причине <code>RR</code> также включает &quot;задержку после последнего отчета отправителя&quot; (delay after last sender report, DLSR). <code>DLSR</code> используется для корректировки вычисления времени туда и обратно. После получения отправителем <code>RR</code> он вычитает <code>sendertime1</code> и <code>DLSR</code> из текущего времени <code>sendertime2</code>. Эта разница во времени называется временем в пути туда и обратно (round-trip time, rtt).</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rtt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = sendertime2 - sendertime1 - DLSR</span></span></code></pre></div><p><code>RTT</code> простыми словами:</p><ul><li>я отправляю тебе сообщение, мои часы показывают 16 часов 20 минут 42 секунды и 420 миллисекунд;</li><li>ты присылаешь мне такое же время в ответ;</li><li>ты также присылаешь время, прошедшее между получением моего сообщения и отправкой твоего сообщения, скажем, 5 мс;</li><li>после получения твоего сообщения, я снова смотрю на часы;</li><li>теперь они показывают 16 ч 20 мин 42 сек 690 мс;</li><li>это означает, что передача сообщения туда и обратно заняла 265 мс (690 - 420 - 5);</li><li>таким образом, время туда и обратно составляет 265 мс.</li></ul><img src="https://habrastorage.org/webt/os/dv/tw/osdvtwdu2mdakskpaicfdkrbwhc.png" alt=""><br><h3 id="tmmbr-tmmbn-remb-и-twcc-в-сочетании-с-gcc" tabindex="-1">TMMBR, TMMBN, REMB и TWCC в сочетании с GCC <a class="header-anchor" href="#tmmbr-tmmbn-remb-и-twcc-в-сочетании-с-gcc" aria-label="Permalink to “TMMBR, TMMBN, REMB и TWCC в сочетании с GCC”">​</a></h3><h5 id="google-congestion-control-gcc" tabindex="-1">Google Congestion Control (GCC) <a class="header-anchor" href="#google-congestion-control-gcc" aria-label="Permalink to “Google Congestion Control (GCC)”">​</a></h5><p>Алгоритм Google Congestion Control (GCC), описанный в общих чертах в <a href="https://datatracker.ietf.org/doc/html/draft-ietf-rmcat-gcc-02" target="_blank" rel="noreferrer">draft-ietf-rmcat-gcc-02</a>, пытается решить проблему расчета пропускной способности. Он сочетается с множеством других протоколов для снижения требований, необходимых для установки соединения. Он хорошо подходит как для принимающей стороны (при работе с <a href="https://chromium.googlesource.com/external/webrtc/+/3c1e558449309be965815e1bf/webrtc/modules/rtp_rtcp/source/rtcp_packet/tmmbr.cc" target="_blank" rel="noreferrer"><code>TMMBR</code></a>/<a href="https://chromium.googlesource.com/external/webrtc/+/HEAD/modules/rtp_rtcp/source/rtcp_packet/tmmbn.cc" target="_blank" rel="noreferrer"><code>TMMBN</code></a> или <a href="https://webrtcglossary.com/remb/" target="_blank" rel="noreferrer"><code>REMB</code></a>), так и для отправляющей стороны (при работе с <a href="https://webrtcglossary.com/transport-cc/" target="_blank" rel="noreferrer"><code>TWCC</code></a>).</p><p><code>GCC</code> фокусируется на потерях пакетов и колебаниях времени прибытия кадров в качестве двух основных показателей для расчета пропускной способности. Он пропускает эти показатели через два связанных контроллера: для вычисления потерь (loss-based) и для вычисления задержки (delay-based).</p><p>Первый компонент <code>GCC</code> - контроллер для вычисления потерь, является очень простым:</p><ul><li>если потери пакета превышают <code>10%</code>, оценка пропускной способности снижается;</li><li>если потери находятся в диапазоне <code>2-10%</code>, оценка остается неизменной;</li><li>если потери ниже <code>2%</code>, оценка увеличивается.</li></ul><p>Вычисления производятся не реже одного раза в секунду. В зависимости от парного протокола, о потере пакетов может либо сообщаться в явном виде (<code>TWCC</code>), либо потеря может предполагаться (<code>TMMBR/TMMBN</code> и <code>REMB</code>).</p><p>Вторая функция взаимодействует с контроллером для вычисления потерь и отслеживает изменения времени прибытия пакетов. Данный контроллер определяет, когда сетевые каналы становятся перегруженными, и снижает оценку пропускной способности. Идея состоит в том, что перегруженный интерфейс будет помещать пакеты в очередь до тех пор, пока не будет исчерпана емкость его буфера. Если такой интерфейс будет получать больше трафика, чем он может отправить, он будет вынужден отбрасывать (drop) пакеты, не помещающиеся в его буферном пространстве. Такой тип потери пакетов особенно опасен для сетей с малой задержкой или работающих в режиме реального времени, он также может негативно влиять на все типы коммуникаций в сети, поэтому его следует, по возможности, избегать. Таким образом, <code>GCC</code> пытается определить, растет ли глубина очереди сети перед началом действительной потери пакетов. Он уменьшает пропускную способность, если наблюдается увеличение задержек в очереди.</p><p>Для решения этой задачи <code>GCC</code> пытается определить увеличение глубины очереди (queue depth), измеряя незначительное увеличение времени приема-передачи. Он записывает &quot;время между прибытиями&quot; (inter-arrival time) кадров <code>t(i) - t(i-1)</code> - разницу во времени прибытия двух групп пакетов (как правило, последовательных видеокадров). Эти группы часто отправляются через равные промежутки времени (например, каждые <code>1/24</code> секунды для видео с частотой <code>24 кадра в секунду</code>). В результате измерение времени между прибытиями становится таким же простым, как измерение разницы во времени между началом первой группы пакетов (т.е. кадра) и первым кадром следующей группы.</p><p>На представленной ниже диаграмме среднее увеличение задержки между пакетами составляет <code>+20мс</code>, что является явным показателем перегрузки сети.</p><img src="https://habrastorage.org/webt/ai/fv/mq/aifvmqgoamebfwqc-ctd2zfpzom.png" alt=""><br><p>Увеличение времени между прибытиями групп пакетов является свидетельством увеличения глубины очереди в подключенных сетевых интерфейсах и, как следствие, перегрузки сети. <em>Обратите внимание</em>: <code>GCC</code> достаточно умен, чтобы учитывать колебания размеров байтов кадра. <code>GCC</code> уточняет проведенные измерения задержки с помощью <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80_%D0%9A%D0%B0%D0%BB%D0%BC%D0%B0%D0%BD%D0%B0" target="_blank" rel="noreferrer">фильтра Калмана</a> и выполняет множество измерений времени приема-передачи (и его вариаций), прежде чем делать вывод о перегрузке сети. Фильтр Калмана в <code>GCC</code> можно считать заменой <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D1%8F" target="_blank" rel="noreferrer">линейной регрессии</a>: он позволяет делать точные прогнозы с учетом джиттера, добавляющего шум (noise) в измерения времени. При определении перегрузки <code>GCC</code> уменьшает доступный битрейт. В условиях стабильной сети он может медленно увеличивать оценку пропускной способности для проверки более высоких значений нагрузки.</p><h4 id="tmmbr-tmmbn-и-remb" tabindex="-1">TMMBR, TMMBN и REMB <a class="header-anchor" href="#tmmbr-tmmbn-и-remb" aria-label="Permalink to “TMMBR, TMMBN и REMB”">​</a></h4><p>Для <code>TMMBR</code>, <code>TMMBN</code> и <code>REMB</code> получатель сначала вычисляет доступную входящую пропускную способность (с помощью <code>GCC</code>, например), затем передает эту информацию отправителю. Сторонам не нужно обмениваться информацией о потере пакетов или других характеристиках сети, поскольку операции, выполняемые на стороне получателя, позволяют измерить время между прибытиями и потерю пакетов напрямую. Вместо этого <code>TMMBR</code>, <code>TMMBN</code> и <code>REMB</code> обмениваются оценками пропускной способности:</p><ul><li><code>Temporary Maximum Media Stream Bit Rate Request</code> (запрос временного максимального битрейта медиапотока) - <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D1%81%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C" target="_blank" rel="noreferrer">мантисса/экспонента</a> запрошенного битрейта для одного <code>SSRC</code>;</li><li><code>Temporary Maximum Media Stream Bit Rate Notification</code> (уведомление о временном максимальном битрейте медиапотока) - уведомление о получении <code>TMMBR</code>;</li><li><code>Receiver Estimated Maximum Bitrate</code> (расчетный максимальный битрейт получателя) - мантисса/экспонента запрошенного битрейта для всего сеанса.</li></ul><p><code>TMMBR</code> и <code>TMMBN</code> появились первыми и определены в <a href="https://datatracker.ietf.org/doc/html/rfc5104" target="_blank" rel="noreferrer">RFC 5104</a>. <code>REMB</code> появился позже, был разработан черновик <a href="https://datatracker.ietf.org/doc/html/draft-alvestrand-rmcat-remb-03" target="_blank" rel="noreferrer"> draft-alvestrand-rmcat-remb</a>, который так и не был стандартизирован.</p><p>Иллюстрация сессии с использованием <code>REMB</code>:</p><img src="https://habrastorage.org/webt/14/z2/g0/14z2g0pg1ar14htve1-vfgb8qee.png" alt=""><br><p>Данный метод хорошо работает на бумаге. Отправитель получает оценку от получателя, устанавливает битрейт кодировщика в полученное значение. Вуаля! Мы адаптировались к сетевым условиям.</p><p>Однако на практике <code>REMB</code> имеет некоторые недостатки.</p><p>Первым недостатком является неэффективность кодировщика. Когда мы устанавливаем для него битрейт, результат кодировки не обязательно будет соответствовать указанному значению. Мы можем получить больше или меньше битов в зависимости от настроек кодировщика и кодируемого кадра.</p><p>Например, результат работы кодировщика <code>x264</code> с настройкой <code>tune=zerolatency</code> может существенно отличаться от установленного целевого битрейта. Один из возможных сценариев:</p><ul><li>предположим, что наш начальный битрейт составляет <code>1000 кбит/с</code>;</li><li>кодировщик выдает только <code>700 кбит/с</code>, поскольку ему не хватает высокочастотных признаков (high frequency features) для кодирования;</li><li>допустим, что получателю приходит видео <code>700 кбит/с</code> с нулевой потерей пакетов. Затем он применяет правило <code>REMB 1</code> для увеличения входящего битрейта на <code>8%</code>;</li><li>получатель отправляет пакет <code>REMB</code> с предложением об увеличении битрейта до <code>756 кбит/с</code> (<code>700 кбит/с * 1.08</code>) отправителю;</li><li>отправитель устанавливает битрейт кодирования в значение <code>756 кбит/с</code>;</li><li>кодировщик выдает еще более низкий битрейт;</li><li>данный процесс повторяется снова и снова, что приводит к снижению битрейта до абсолютного минимума.</li></ul><p>В конечном счете, это приведет к недоступному для просмотра видео даже при наличии прекрасного соединения.</p><h4 id="transport-wide-congestion-control" tabindex="-1">Transport Wide Congestion Control <a class="header-anchor" href="#transport-wide-congestion-control" aria-label="Permalink to “Transport Wide Congestion Control”">​</a></h4><p><code>TWCC</code> (контроль перегрузки на транспортном уровне) - одно из последних достижений в области оценки состояния сетевой коммуникации. Он определен в черновике <a href="https://datatracker.ietf.org/doc/html/draft-holmer-rmcat-transport-wide-cc-extensions-01" target="_blank" rel="noreferrer">draft-holmer-rmcat-transport-wide-cc-extensions-01</a>.</p><p>В <code>TWCC</code> используется простой принцип:</p><img src="https://habrastorage.org/webt/_h/ae/rv/_haerviqtpcalte7gmjmgd7atqo.png" alt=""><br><p>В случае с <code>REMB</code> получатель сообщает отправителю о доступном битрейте загрузки. Он использует точные измерения предполагаемой потери пакетов и данные о времени между прибытиями пакетов.</p><p><code>TWCC</code> - своего рода симбиоз протоколов <code>SR/RR</code> и <code>REMB</code>. Оценка пропускной способности возлагается на отправителя (как в <code>SR/RR</code>), но техника оценки больше похожа на <code>REMB</code>.</p><p>В <code>TWCC</code> получатель сообщает отправителю время прибытия каждого пакета. Эта информация является достаточной для того, чтобы отправитель мог измерить различные варианты задержек между прибытиями пакетов, а также идентифицировать потерянные и опоздавшие пакеты. При частом обмене такой информацией отправитель имеет возможность быстро адаптироваться к изменениям условий сети и корректировать пропускную способность с помощью таких алгоритмов, как <code>GCC</code>.</p><p>Отправитель следит за отправкой пакетов, их последовательными номерами, размером и временем отправки. При получении сообщения <code>RTCP</code> от получателя он сравнивает отправленную задержку между прибытиями пакетов с полученной. Увеличение получаемой задержки свидетельствует о перегрузке сети, в этом случае отправитель принимает необходимые меры по ее снижению.</p><p>Предоставляя отправителю необработанные данные, <code>TWCC</code> обеспечивает объективную оценку реальных условий сети:</p><ul><li>почти мгновенную информацию о потере пакетов, вплоть до индивидуальных пакетов;</li><li>точный битрейт отправки;</li><li>точный битрейт получения;</li><li>измерение джиттера;</li><li>разницу между задержками отправки и получения;</li><li>описание того, как сеть справляется с волнообразной или стабильной пропускной способностью.</li></ul><p>Одним из наиболее существенных преимуществ <code>TWCC</code> является гибкость, которую он предоставляет разработчикам <code>WebRTC</code>. Поскольку алгоритмы контроля перегрузки применяются на стороне отправителя, клиентский код может оставаться простым и легко масштабируемым. Сложные алгоритмы контроля перегрузки могут реализовываться быстрее на оборудовании, которым они непосредственно управляют (например, Selective Forwarding Unit - единица выборочной пересылки, обсуждаемая в следующем разделе). Для браузеров и мобильных устройств это означает, что клиенты могут извлекать выгоду из улучшений алгоритма, не дожидаясь стандартизации или обновления браузера (что может занимать продолжительное время).</p><h3 id="другие-способы-оценки-пропускнои-способности" tabindex="-1">Другие способы оценки пропускной способности <a class="header-anchor" href="#другие-способы-оценки-пропускнои-способности" aria-label="Permalink to “Другие способы оценки пропускной способности”">​</a></h3><p>Наиболее разработанной реализацией является &quot;A Google Congestion Control Algorithm for Real-Time Communication&quot; (алгоритм контроля перегрузки для коммуникации в реальном времени), определенный в <a href="https://tools.ietf.org/html/draft-alvestrand-rmcat-congestion-02" target="_blank" rel="noreferrer">draft-alvestrand-rmcat-congestion</a>.</p><p>Существует несколько альтернатив <code>GCC</code>, например, <a href="https://datatracker.ietf.org/doc/html/draft-zhu-rmcat-nada-04" target="_blank" rel="noreferrer">NADA: A Unified Congestion Control Scheme for Real-Time Media</a> и <a href="https://datatracker.ietf.org/doc/html/draft-johansson-rmcat-scream-cc-05" target="_blank" rel="noreferrer">SCReAM - Self-Clocked Rate Adaptation for Multimedia</a>.</p><h2 id="обмен-другими-данными" tabindex="-1">Обмен другими данными <a class="header-anchor" href="#обмен-другими-данными" aria-label="Permalink to “Обмен другими данными”">​</a></h2><p><code>WebRTC</code> предоставляет каналы (data channels) для обмена данными (data communication). Между двумя пирами можно открыть до <code>65 534</code> каналов. Канал данных основан на <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D1%82%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0" target="_blank" rel="noreferrer">датаграммах</a> (datagram) и имеет определенную продолжительность (durability). По умолчанию канал данных гарантирует сохранения порядка сообщений.</p><p>На первый взгляд каналы данных могут казаться лишними. Зачем нам эта подсистема, когда мы можем использовать <code>HTTP</code> или веб-сокеты для обмена данными?</p><p>Одна из особенностей каналов данных состоит в том, что в результате настройки они могут стать неким подобием <code>UDP</code> с неупорядоченной/ненадежной доставкой сообщений. Это может потребоваться в ситуациях, когда критически важными являются низкая задержка и высокая производительность. Мы можем провести измерения и обеспечить отправку только такого количества сообщений, с которым гарантированно справится наша сеть.</p><h3 id="как-это-работает-4" tabindex="-1">Как это работает? <a class="header-anchor" href="#как-это-работает-4" aria-label="Permalink to “Как это работает?”">​</a></h3><p>Для обмена данными <code>WebRTC</code> использует <code>SCTP</code>, определенный в <a href="https://tools.ietf.org/html/rfc4960" target="_blank" rel="noreferrer">RFC 4960</a>. <code>SCTP</code> - это транспортный протокол, являющийся альтернативой <code>TCP</code> и <code>UDP</code>. В <code>WebRTC</code> он используется как протокол уровня приложения поверх соединения <code>DTLS</code>.</p><p><code>SCTP</code> состоит из потоков, каждый из которых может настраиваться независимо от других. Каналы данных - это всего лишь абстракция потоков. Настройки, связанные с продолжительностью существования канала и порядком доставки сообщений, просто передаются агенту <code>SCTP</code>.</p><p>Каналы данных имеют некоторые возможности, отсутствующие в <code>SCTP</code>, например, метки каналов (channel labels). Для этого используется Протокол установки канала данных (Data Channel Establishment Protocol, DCEP), определенный в <a href="https://tools.ietf.org/html/rfc8832" target="_blank" rel="noreferrer">RFC 8832</a>. <code>DCEP</code> определяет сообщения для взаимодействия с меткой канала и протоколом.</p><h3 id="dcep" tabindex="-1">DCEP <a class="header-anchor" href="#dcep" aria-label="Permalink to “DCEP”">​</a></h3><p><code>DCEP</code> содержит два сообщения: <code>DATA_CHANNEL_OPEN</code> и <code>DATA_CHANNEL_ACK</code>. Открытый канал должен получить <code>ACK</code> от удаленного пира.</p><h4 id="data-channel-open" tabindex="-1">DATA_CHANNEL_OPEN <a class="header-anchor" href="#data-channel-open" aria-label="Permalink to “DATA_CHANNEL_OPEN”">​</a></h4><p>Данное сообщение отправляется агентом, желающим открыть соединение.</p><p><strong>Формат пакета</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|  Message Type |  Channel Type |            Priority           |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                    Reliability Parameter                      |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|         Label Length          |       Protocol Length         |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>/                             Label                             /</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>/                            Protocol                           /</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p><strong>Message Type</strong></p><p><code>Message Type</code> (тип сообщения) имеет фиксированное значение <code>0x03</code>.</p><p><strong>Channel Type</strong></p><p><code>Channel Type</code> (тип канала) определяет такие атрибуты канала, как продолжительность и порядок. Может иметь следующие значения:</p><ul><li><code>DATA_CHANNEL_RELIABLE</code> (<code>0x00</code>) - сообщения не были потеряны и будут прибывать в правильном порядке;</li><li><code>DATA_CHANNEL_RELIABLE_UNORDERED</code> (<code>0x80</code>) - сообщения не были потеряны, но могут прибывать в неправильном порядке;</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT</code> (<code>0x01</code>) - сообщения могут быть потеряны (после выполнения всех попыток), но будут прибывать в правильном порядке;</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED</code> (<code>0x81</code>) - сообщения могут быть потеряны (после выполнения всех попыток) и могут прибывать в неправильном порядке;</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_TIMED</code> (<code>0x02</code>) - сообщения могут быть потеряны (если они не прибывают в запрошенное время), но будут прибывать в правильном порядке;</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED</code> (<code>0x82</code>) - сообщения могут быть потеряны (если они не прибывают в запрошенное время) и могут прибывать в неправильном порядке.</li></ul><p><strong>Priority (приоритет)</strong></p><p>Определяет приоритет канала. Каналы с более высоким приоритетом создаются раньше. Большие сообщения с низким приоритетом не задерживают отправку сообщений с высоким приоритетом.</p><p><strong>Reliability Parameter (параметр надежности)</strong></p><p>Если типом канала является <code>DATA_CHANNEL_PARTIAL_RELIABLE</code>, суффикс определяет следующее поведение:</p><ul><li><code>REXMIT</code> - определяет количество попыток отправки сообщения;</li><li><code>TIMED</code> - определяет, как долго отправитель будет пытаться отправить сообщение (в мс).</li></ul><p><strong>Label (метка, подпись)</strong></p><p>Строка в формате <code>UTF-8</code>, содержащая название канала данных. Данная строка может быть пустой.</p><p><strong>Protocol (протокол)</strong></p><p>Если данная строка является пустой, протокол считается неопределенным. Если строка не является пустой, в ней должно содержаться значение из &quot;Реестра имен подпротокола WebSocket&quot; (WebSocket Subprotocol Name Registry), определенного в <a href="https://tools.ietf.org/html/rfc6455#page-61" target="_blank" rel="noreferrer">RFC 6455</a>.</p><h4 id="data-channel-ack" tabindex="-1">DATA_CHANNEL_ACK <a class="header-anchor" href="#data-channel-ack" aria-label="Permalink to “DATA_CHANNEL_ACK”">​</a></h4><p>Данное сообщение является подтверждением открытия канала данных, передаваемого от отправителя получателю.</p><p><strong>Формат пакета</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|  Message Type |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+</span></span></code></pre></div><h3 id="sctp" tabindex="-1">SCTP <a class="header-anchor" href="#sctp" aria-label="Permalink to “SCTP”">​</a></h3><p><code>SCTP</code> предоставляет следующие возможности:</p><ul><li>мультиплексирование;</li><li>надежная доставка сообщений (для этого используется механизм передачи, подобный <code>TCP</code>);</li><li>настройки частичной надежности (partial-reliability options);</li><li>предотвращение перегрузки;</li><li>контроль потока.</li></ul><p>Мы разделим рассмотрение <code>SCTP</code> на три части.</p><h3 id="концепция" tabindex="-1">Концепция <a class="header-anchor" href="#концепция" aria-label="Permalink to “Концепция”">​</a></h3><p><code>SCTP</code> предоставляет большое количество возможностей. Мы рассмотрим только те возможности, которые используются в <code>WebRTC</code>. К возможностям, которые не используются <code>WebRTC</code>, относятся множественная адресация (multi-homing) и выбор пути.</p><p><code>SCTP</code> разрабатывается более 20 лет, так что его непросто понять.</p><h4 id="ассоциация" tabindex="-1">Ассоциация <a class="header-anchor" href="#ассоциация" aria-label="Permalink to “Ассоциация”">​</a></h4><p>Ассоциация (assosiation) - термин, относящийся к сессии <code>SCTP</code>. Это состояние, распределяемое между двумя взаимодействующими агентами.</p><h4 id="потоки" tabindex="-1">Потоки <a class="header-anchor" href="#потоки" aria-label="Permalink to “Потоки”">​</a></h4><p>Поток (stream) - это двунаправленная последовательность пользовательских данных. Канал данных - это поток. Каждая ассоциация <code>SCTP</code> содержит список потоков. Каждый поток может обладать разным типом надежности.</p><p><code>WebRTC</code> позволяет настраивать поток только в момент создания, но <code>SCTP</code> позволяет менять настройки в любое время.</p><h4 id="датаграммы" tabindex="-1">Датаграммы <a class="header-anchor" href="#датаграммы" aria-label="Permalink to “Датаграммы”">​</a></h4><p>Кадры (фреймы, frames) <code>SCTP</code> - это набор датаграмм, а не байтовый поток. Отправка и получение данных похожа на использование <code>UDP</code> вместо <code>TCP</code>. Для передачи нескольких сообщений через один поток не нужен дополнительный код.</p><p>Сообщения <code>SCTP</code> не имеют ограничений по размеру, в отличие от сообщений <code>UDP</code>. Одно сообщение <code>SCTP</code> может иметь размер в несколько гигабайт.</p><h4 id="части" tabindex="-1">Части <a class="header-anchor" href="#части" aria-label="Permalink to “Части”">​</a></h4><p>Протокол <code>SCTP</code> состоит из частей (chunks). Существуют различные типы частей. Эти части используются для всей коммуникации. Пользовательские данные, установка соединения, контроль перегрузки и т.д. - все это делается с помощью частей.</p><p>Каждый пакет <code>SCTP</code> состоит из списка частей. Поэтому в одном пакете <code>UDP</code> может содержаться несколько частей с сообщениями из разных потоков.</p><h4 id="последовательныи-номер-передачи" tabindex="-1">Последовательный номер передачи <a class="header-anchor" href="#последовательныи-номер-передачи" aria-label="Permalink to “Последовательный номер передачи”">​</a></h4><p>Последовательный номер передачи (Transmission Sequence Number, TSN) - это глобальный уникальный идентификатор частей <code>DATA</code>. Часть <code>DATA</code> содержит все сообщения, которые желает отправить пользователь. <code>TSN</code> помогает получателю определять потерю или неправильный порядок пакетов.</p><p>Если получатель замечает отсутствующий <code>TSN</code>, он не передает данные пользователю до решения этой проблемы.</p><h4 id="идентификатор-потока" tabindex="-1">Идентификатор потока <a class="header-anchor" href="#идентификатор-потока" aria-label="Permalink to “Идентификатор потока”">​</a></h4><p>Каждый поток имеет уникальный идентификатор. При создании канала данных с явным <code>ID</code>, этот <code>ID</code> просто передается <code>SCTP</code> в качестве идентификатора потока. Если такой <code>ID</code> отсутствует, он генерируется автоматически.</p><h4 id="идентификатор-протокола-полезнои-нагрузки" tabindex="-1">Идентификатор протокола полезной нагрузки <a class="header-anchor" href="#идентификатор-протокола-полезнои-нагрузки" aria-label="Permalink to “Идентификатор протокола полезной нагрузки”">​</a></h4><p>Каждая часть <code>DATA</code> также имеет идентификатор протокола полезной нагрузки (Payload Protocol Identifier, PPID). Он используется для идентификации типа передаваемых данных. <code>SCTP</code> имеет много <code>PPID</code>, но в <code>WebRTC</code> используются следующие пять:</p><ul><li><code>WebRTC DCEP</code> (<code>50</code>) - сообщения <code>DCEP</code>;</li><li><code>WebRTC String</code> (<code>51</code>) - строковые сообщения <code>DataChannel</code>;</li><li><code>WebRTC Binary</code> (<code>53</code>) - бинарные сообщения <code>DataChannel</code>;</li><li><code>WebRTC String Empty</code> (<code>56</code>) - строковое сообщения <code>DataChannel</code> с нулевой длиной (пустое строковое сообщение);</li><li><code>WebRTC Binary Empty</code> (<code>57</code>) - бинарное сообщения <code>DataChannel</code> с нулевой длиной (пустое бинарное сообщение).</li></ul><h3 id="протокол" tabindex="-1">Протокол <a class="header-anchor" href="#протокол" aria-label="Permalink to “Протокол”">​</a></h3><p>Ниже представлены некоторые &quot;чанки&quot;, которые используются в <code>WebRTC</code>.</p><p>Каждый чанк начинается с поля <code>type</code>. Перед списком чанков находится заголовок (header).</p><h4 id="data" tabindex="-1">DATA <a class="header-anchor" href="#data" aria-label="Permalink to “DATA”">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Type = 0    | Reserved|U|B|E|    Length                     |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                              TSN                              |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|      Stream Identifier        |   Stream Sequence Number      |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                  Payload Protocol Identifier                  |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>/                            User Data                          /</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p>Чанк <code>DATA</code> используется для передачи пользовательских данных. Когда мы что-то отправляем через канал данных, используется этот чанк.</p><p>Бит <code>U</code> устанавливается, если данный пакет является неупорядоченным (unordered). Мы можем игнорировать последовательный номер потока.</p><p><code>B</code> и <code>E</code> - это начальный и конечный биты. Если мы хотим отправить сообщение, которое является слишком большим для одного чанка <code>DATA</code>, оно будет разделено (fragmented) на несколько чанков <code>DATA</code>, передаваемых в нескольких пакетах. Для этого <code>SCTP</code> использует биты <code>B</code> и <code>E</code>, а также последовательные номера.</p><ul><li><code>B=1</code>, <code>E=0</code> - первая часть фрагментированного сообщения пользователя;</li><li><code>B=0</code>, <code>E=0</code> - средняя часть фрагментированного сообщения пользователя;</li><li><code>B=0</code>, <code>E=1</code> - последняя часть фрагментированного сообщения пользователя;</li><li><code>B=1</code>, <code>E=1</code> - целое (нефрагментированное) сообщение.</li></ul><p><code>TSN</code> - последовательный номер передачи, уникальный идентификатор данного чанка <code>DATA</code>. После <code>4 294 967 295</code> чанка <code>TSN</code> обнуляется. <code>TSN</code> увеличивается на единицу для каждого чанка во фрагментированном сообщении пользователя, что позволяет получателю определять порядок чанков для восстановления исходного сообщения.</p><p><code>Stream Identifier</code> - уникальный идентификатор потока, которому принадлежат данные.</p><p><code>Stream Sequence Number</code> - это 16-битный номер, увеличивающийся при каждом сообщении и включаемый в заголовок сообщения чанка <code>DATA</code>. После <code>65 535</code> сообщения <code>SSN</code> обнуляется. Это число используется для определения порядка доставки сообщений получателю, когда <code>U</code> имеет значение <code>0</code>. <code>SSN</code> похож на <code>TSN</code>, но он увеличивается для каждого сообщения, а не для каждого чанка.</p><p><code>Payload Protocol Identifier</code> - тип данных, передаваемых через поток. В случае с <code>WebRTC</code> он будет <code>DCEP</code>, строкой или двоичными данными.</p><p><code>User Data</code> - это то, что мы отправляем. Все данные, передаваемые через <code>WebRTC</code>, передаются через чанк <code>DATA</code>.</p><h4 id="init" tabindex="-1">INIT <a class="header-anchor" href="#init" aria-label="Permalink to “INIT”">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Type = 1    |  Chunk Flags  |      Chunk Length             |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                         Initiate Tag                          |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|           Advertised Receiver Window Credit (a_rwnd)          |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|  Number of Outbound Streams   |  Number of Inbound Streams    |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                          Initial TSN                          |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>/              Optional/Variable-Length Parameters              /</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p>Чанк <code>INIT</code> запускает процесс создания ассоциации.</p><p><code>Initiate Tag</code> используется для генерации <a href="https://ru.wikipedia.org/wiki/Cookie" target="_blank" rel="noreferrer">куки (cookie)</a>. Куки используются для предотвращения атак <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%B0%D0%BA%D0%B0_%D0%BF%D0%BE%D1%81%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA%D0%B0" target="_blank" rel="noreferrer">&quot;Человек посередине&quot;</a> и <a href="https://ru.wikipedia.org/wiki/DoS-%D0%B0%D1%82%D0%B0%D0%BA%D0%B0" target="_blank" rel="noreferrer">&quot;Отказ в обслуживании&quot;</a>.</p><p><code>Advertised Receiver Window Credit</code> используется для контроля перегрузки <code>SCTP</code>. Это поле определяет размер буфера, выделенного получателем для данной ассоциации.</p><p><code>Number of Outbound/Inbound Streams</code> уведомляет удаленный пир о количестве потоков, поддерживаемых данным агентом.</p><p><code>Initial TSN</code> - произвольное число (<code>uint32</code>), с которого начинается локальный <code>TSN</code>.</p><p>Поле <code>Optional Parameters</code> предназначено для добавления в протокол новых возможностей.</p><h4 id="sack" tabindex="-1">SACK <a class="header-anchor" href="#sack" aria-label="Permalink to “SACK”">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Type = 3    |Chunk  Flags   |      Chunk Length             |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                      Cumulative TSN Ack                       |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|          Advertised Receiver Window Credit (a_rwnd)           |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>| Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>/                                                               /</span></span>
<span class="line"><span>\                              ...                              \</span></span>
<span class="line"><span>/                                                               /</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Gap Ack Block #N Start      |  Gap Ack Block #N End         |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                       Duplicate TSN 1                         |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>/                                                               /</span></span>
<span class="line"><span>\                              ...                              \</span></span>
<span class="line"><span>/                                                               /</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                       Duplicate TSN X                         |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p>Чанк <code>SACK</code> - это подтверждение получения пакета получателем. До получения отправителем <code>SACK</code> для <code>TSN</code> он будет повторно отправлять чанк <code>DATA</code> по запросу. Но <code>SACK</code> не только обновляет <code>TSN</code>.</p><p><code>Cumulative TSN ACK</code> - максимальный полученный <code>TSN</code>.</p><p><code>Advertised Receiver Window Credit</code> - размер буфера получателя. Это значение может меняться в течение сессии, если у получателя появится больше свободной памяти.</p><p><code>Ack Blocks</code> - это <code>TSN</code>, полученные после <code>Cumulative TSN ACK</code>. Это значение используется при наличии бреши в доставленных пакетах. Допустим, были доставлены чанки <code>DATA</code> с <code>TSN</code>, имеющими значения <code>100</code>, <code>102</code>, <code>103</code> и <code>104</code>. <code>Cumulative TSN ACK</code> будет иметь значение <code>100</code>, но <code>Ack Blocks</code> может использоваться для уведомления отправителя об отсутствии необходимости в повторной отправке чанков <code>102</code>, <code>103</code> и <code>104</code>.</p><p><code>Duplicate TSN</code> информирует отправителя, что он получил указанные чанки <code>DATA</code> более одного раза.</p><h4 id="heartbeat" tabindex="-1">HEARTBEAT <a class="header-anchor" href="#heartbeat" aria-label="Permalink to “HEARTBEAT”">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Type = 4    | Chunk  Flags  |      Heartbeat Length         |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>/            Heartbeat Information TLV (Variable-Length)        /</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p>Чанк <code>HEARTBEAT</code> используется для проверки активности удаленного пира. Может использоваться для обеспечения открытости <code>NAT</code> без отправки чанков <code>DATA</code>.</p><h4 id="abort" tabindex="-1">ABORT <a class="header-anchor" href="#abort" aria-label="Permalink to “ABORT”">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Type = 6    |Reserved     |T|           Length              |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>/                                                               /</span></span>
<span class="line"><span>\               Zero or more Error Causes                       \</span></span>
<span class="line"><span>/                                                               /</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p>Чанк <code>ABORT</code> резко закрывает ассоциацию. Используется, когда одна из сторон переходит в состояние ошибки (error state). Для плавного закрытия соединения используется чанк <code>SHUTDOWN</code>.</p><h4 id="shutdown" tabindex="-1">SHUTDOWN <a class="header-anchor" href="#shutdown" aria-label="Permalink to “SHUTDOWN”">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Type = 7    | Chunk  Flags  |      Length = 8               |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                      Cumulative TSN Ack                       |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p>Чанк <code>SHUTDOWN</code> запускает процесс плавного закрытия ассоциации <code>SCTP</code>. Каждый агент информирует другую сторону о последнем полученном <code>TSN</code>. Это позволяет убедиться в том, что никакие пакеты не были потеряны. <code>WebRTC</code> не закрывает ассоциацию автоматически. Поэтому каждый канал данных должен быть закрыт вручную.</p><p><code>Cumulative TSN ACK</code> - последний отправленный <code>TSN</code>. Каждая сторона закрывает соединение только после получения чанка <code>DATA</code> с этим <code>TSN</code>.</p><h4 id="error" tabindex="-1">ERROR <a class="header-anchor" href="#error" aria-label="Permalink to “ERROR”">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Type = 9    | Chunk  Flags  |           Length              |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>/                 Одна или более причина ошибки                 /</span></span>
<span class="line"><span>\                                                               \</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p>Чанк <code>ERROR</code> используется для уведомления другой стороны о возникновении не критичной для ассоциации ошибки.</p><h4 id="tsn-forward" tabindex="-1">TSN FORWARD <a class="header-anchor" href="#tsn-forward" aria-label="Permalink to “TSN FORWARD”">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|   Type = 192  |  Flags = 0x00 |        Length = Variable      |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|                      New Cumulative TSN                       |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|         Stream-1              |       Stream Sequence-1       |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>\                                                               /</span></span>
<span class="line"><span>/                                                               \</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|         Stream-N              |       Stream Sequence-N       |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><p>Чанк <code>TSN FORWARD</code> сдвигает глобальный <code>TSN</code> вперед. Это позволяет пропустить пакеты, которые нам больше не нужны. Предположим, что мы отправили пакеты <code>10 11 12 13 14 15</code>, которые являются валидными только в случае доставки всех пакетов и только в случае своевременной доставки.</p><p>Если мы потеряли пакеты <code>12</code> и <code>13</code>, в отправке пакетов <code>14</code> и <code>15</code> нет смысла. <code>SCTP</code> использует чанк <code>TSN FORWARD</code> для решения этой задачи. Он сообщает получателю, что пакеты <code>14</code> и <code>15</code> не будут доставлены.</p><p><code>New Cumulative TSN</code> - новый <code>TSN</code> подключения. Любые пакеты, доставленные перед ним, будут отброшены.</p><p><code>Stream</code> и <code>Stream Sequence</code> используются для сдвига вперед <code>Stream Sequence Number</code>.</p><h3 id="конвеиер-sctp" tabindex="-1">Конвейер SCTP <a class="header-anchor" href="#конвеиер-sctp" aria-label="Permalink to “Конвейер SCTP”">​</a></h3><p>Есть несколько интересных вещей, касающихся машины состояния (state machine) <code>SCTP</code>. <code>WebRTC</code> не использует все возможности этой машины - такие возможности мы рассматривать не будем. Мы также упростим некоторые компоненты для их лучшего понимания.</p><h4 id="установка-соединения" tabindex="-1">Установка соединения <a class="header-anchor" href="#установка-соединения" aria-label="Permalink to “Установка соединения”">​</a></h4><p>Чанки <code>INIT</code> и <code>INIT ACK</code> используются для обмена возможностями и настройками каждого пира. <code>SCTP</code> использует куки в процессе рукопожатия для валидации пира, с которым предполагается коммуникация. Это предотвращает перехват рукопожатия и <a href="https://ru.wikipedia.org/wiki/DoS-%D0%B0%D1%82%D0%B0%D0%BA%D0%B0" target="_blank" rel="noreferrer"><code>DoS-атаки</code></a>.</p><p>Чанк <code>INIT ACK</code> содержит куки. Куки возвращаются создателю с помощью <code>COOKIE ECHO</code>. Если верификация куки прошла успешно, отправляется <code>COOKIE ACK</code> и можно обмениваться чанками <code>DATA</code>.</p><img src="https://habrastorage.org/webt/sw/rr/cw/swrrcwnl9zkwf3nijdfao5sufcg.png" alt=""><br><h4 id="завершение-сессии" tabindex="-1">Завершение сессии <a class="header-anchor" href="#завершение-сессии" aria-label="Permalink to “Завершение сессии”">​</a></h4><p>Для этого используется чанк <code>SHUTDOWN</code>. Когда агент получает чанк <code>SHUTDOWN</code>, он ждет получения запрошенного <code>Cumulative TSN ACK</code>. Это позволяет убедиться в доставке всех данных, даже если соединение является ненадежным.</p><h4 id="механизм-поддержания-активности" tabindex="-1">Механизм поддержания активности <a class="header-anchor" href="#механизм-поддержания-активности" aria-label="Permalink to “Механизм поддержания активности”">​</a></h4><p>Для поддержания соединения в активном состоянии используются чанки <code>HEARTBEAT REQUEST</code> и <code>HEARTBEAT ACK</code>. Они отправляются с определенной периодичностью. <code>SCTP</code> также выполняет <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D1%81%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B2%D1%8B%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0" target="_blank" rel="noreferrer">экспоненциальную выдержку</a> (exponential backoff), когда пакеты не доставляются.</p><p>Чанк <code>HEARTBEAT</code> также содержит время, что позволяет двум ассоциациям рассчитать время передачи данных между двумя агентами.</p><h2 id="применение" tabindex="-1">Применение <a class="header-anchor" href="#применение" aria-label="Permalink to “Применение”">​</a></h2><p>Данный раздел посвящен тому, что можно создать с помощью <code>WebRTC</code>, а также тому, как это делается. Все возможности <code>WebRTC</code> имеют свою цену и ценность. Разработка реальных приложений <code>WebRTC</code> - задача не из простых.</p><h3 id="случаи-использования" tabindex="-1">Случаи использования <a class="header-anchor" href="#случаи-использования" aria-label="Permalink to “Случаи использования”">​</a></h3><p>Многие считают, что <code>WebRTC</code> - это про конференции в браузере. Однако, это намного больше. <code>WebRTC</code> используется в широком спектре приложений. Все время появляется что-то новое.</p><h4 id="конференц-связь" tabindex="-1">Конференц-связь <a class="header-anchor" href="#конференц-связь" aria-label="Permalink to “Конференц-связь”">​</a></h4><p>Конференц-связь (conferencing) - стандартный случай использования <code>WebRTC</code>. Протокол содержит несколько возможностей, которых не содержит ни один другой протокол. Систему конференц-связи можно построить с помощью <code>WebSocket</code> и она будет работать. Но в условиях реальных сетей <code>WebRTC</code> - лучший выбор.</p><p><code>WebRTC</code> предоставляет контроль перегрузки и автоматически адаптируемый битрейт для медиа. При изменении сетевых условий пользователи всегда будут иметь наилучший опыт использования приложения. Разработчикам не нужно писать дополнительный код для измерения этих условий.</p><p>Участники конференции могут отправлять и получать несколько потоков одновременно. Они также могут добавлять и удалять потоки в любое время в течение сессии. Используемые кодеки также предварительно согласовываются. Весь этот функционал предоставляется браузером.</p><p>Такая конференция также выигрывает от наличия каналов данных. Пользователи могут обмениваться дополнительными данными (metadata) или документами. Мы можем создать несколько потоков и сделать некоторые из них более производительными в ущерб надежной доставке сообщений.</p><h4 id="вещание" tabindex="-1">Вещание <a class="header-anchor" href="#вещание" aria-label="Permalink to “Вещание”">​</a></h4><p>Все больше новых проектов, в которых используется <code>WebRTC</code>, связаны с вещанием (broadcasting) в той или иной степени. Протокол предоставляет большое количество возможностей как для издателя (publisher), так и для потребителя (consumer) медиа.</p><p><code>WebRTC</code> существенно облегчает процесс публикации видео. Пользователям не нужно устанавливать специальное ПО. Любая платформа с браузером может публиковать видео. Издатели могут отправлять несколько треков и модифицировать или удалять их в любое время. Это является существенным преимуществом перед старыми протоколами, которые позволяли передавать только один аудио или видеотрек через одно соединение.</p><p><code>WebRTC</code> предоставляет разработчикам серьезный контроль над задержкой и качеством. Важно, что задержка никогда не превышает максимальный порог (threshold), и мы можем игнорировать некоторые артефакты декодирования. Мы можем запускать воспроизведение видео сразу после его доставки. С другими протоколами, функционирующими поверх <code>TCP</code>, это сделать не так просто. В браузере мы просто запрашиваем данные и сразу их получаем.</p><h4 id="удаленныи-доступ" tabindex="-1">Удаленный доступ <a class="header-anchor" href="#удаленныи-доступ" aria-label="Permalink to “Удаленный доступ”">​</a></h4><p>Удаленный доступ (remote access) - это когда мы получаем доступ к другому компьютеру через <code>WebRTC</code>. Мы можем контролировать удаленный хост целиком или только отдельное приложение, работающее на нем. Это отлично подходит для выполнения сложных вычислительных задач, когда собственной мощности оказывается недостаточно. <code>WebRTC</code> – это революция сразу в трех направлениях.</p><p><code>WebRTC</code> может использоваться для доступа к удаленному хосту, скрытому от остального мира. С помощью обхода <code>NAT</code> мы можем получить доступ к компьютеру, доступному только через <code>STUN</code>. Это обеспечивает безопасность и конфиденциальность. Пользователям не нужно передавать видео через посредника или &quot;переходник&quot; (ретранслятор). Отображение <code>NAT</code> также облегчает <a href="https://ru.wiktionary.org/wiki/%D0%B4%D0%B5%D0%BF%D0%BB%D0%BE%D0%B9" target="_blank" rel="noreferrer">деплой</a> приложения. Нам не надо беспокоиться о перенаправлении портов или настройке статического <code>IP</code>.</p><p>Каналы данных также активно применяются в этом сценарии использования. Они могут быть настроены таким образом, что будут принимать только последние данные. В случае с <code>TCP</code> мы рискуем столкнуться с блокировкой начала строки (Head-of-line blocking). Клик мыши или нажатие клавиши могут задержаться в пути и блокировать получение следующих за ними событий. Каналы данных спроектированы специально для обработки таких случаев и позволяют отключить повторную отправку потерянных пакетов. Мы также можем измерять нагрузку и проверять, что отправляем ровно столько данных, сколько способна выдержать наша сеть.</p><p>Наличие <code>WebRTC</code> в браузере сильно упрощает жизнь. Нам не нужно скачивать проприетарного (платного) клиента для начала сессии. Все большее количество клиентов имеют встроенную поддержку <code>WebRTC</code>, например, умные телевизоры (Smart TV).</p><h4 id="передача-фаилов-и-обход-цензуры" tabindex="-1">Передача файлов и обход цензуры <a class="header-anchor" href="#передача-фаилов-и-обход-цензуры" aria-label="Permalink to “Передача файлов и обход цензуры”">​</a></h4><p>Передача файлов (File Sharing) и обход цензуры (Censorship Circumvention) - это две совершенно разные проблемы. Однако, <code>WebRTC</code> успешно решает обе. Он делает коммуникацию легкодоступной и практически не поддающейся блокировке.</p><p>Первая задача, которую решает <code>WebRTC</code> - это получение клиента. Если мы хотим присоединиться к файлообменной сети, нам нужно загрузить клиента. Даже если сеть является распределенной, все равно нужен клиент. В ограниченной сети загрузка клиента может быть заблокированной. Даже если получится скачать клиента, сможет ли пользователь самостоятельно установить и запустить его? <code>WebRTC</code> доступен в каждом браузере: это готовый к использованию клиент.</p><p>Вторая проблема - блокировка трафика. Если мы используем протокол, предназначенный только для передачи файлов или обхода цензуры, его легко заблокировать. Поскольку <code>WebRTC</code> - это протокол общего назначения, его блокировка затронет каждого. Блокировка <code>WebRTC</code> может помешать подключению новых участников к конференции.</p><h4 id="интернет-вещеи" tabindex="-1">Интернет вещей <a class="header-anchor" href="#интернет-вещеи" aria-label="Permalink to “Интернет вещей”">​</a></h4><p>Интернет вещей (Internet of Things, IoT) включает в себя несколько вещей. Для многих это означает камеры видеонаблюдения. С помощью <code>WebRTC</code> мы можем передавать видео другому пиру, такому как телефон или браузер. Другим случаем является подключение устройств и обмен чувствительными данными (sensor data). У нас может быть два устройства, функционирующих в локальной сети, которые обмениваются данными о климате, шуме или освещенности.</p><p><code>WebRTC</code> имеет существенные преимущества перед старыми протоколами для обмена потоками. Поскольку <code>WebRTC</code> поддерживает <code>P2P-соединения</code>, мы можем передавать видео с камеры напрямую в браузер. Нет необходимости использовать сторонний сервер. Даже если видео будет зашифрованным, злоумышленник может извлечь некоторую информацию из метаданных звонка.</p><p>Совместимость - еще одно преимущество, предоставляемое <code>WebRTC</code>. <code>WebRTC</code> доступен во многих языках программирования: C#, C++, C, Go, Java, Python, Rust, JavaScript и TypeScript. Это означает, что мы можем использовать язык, который хотим. Нам не требуются проприетарные протоколы или форматы для подключения клиентов.</p><h4 id="обмен-медиаданными-2" tabindex="-1">Обмен медиаданными <a class="header-anchor" href="#обмен-медиаданными-2" aria-label="Permalink to “Обмен медиаданными”">​</a></h4><p>Предположим, что у нас есть &quot;железо&quot; и ПО, генерирующее видео, но мы пока не можем их обновить. Для просмотра видео пользователь должен загрузить проприетарного клиента. Это является фрустрирующим. Ответ - запуск моста (bridge) <code>WebRTC</code>. Мост транслируется между двумя протоколами, поэтому пользователи могут использовать браузер со старыми настройками.</p><p>Во многих форматах, используемые разработчиками, применяются те же протоколы, что и в <code>WebRTC</code>. <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%B5%D0%B0%D0%BD%D1%81%D0%B0" target="_blank" rel="noreferrer">Протокол установления сеанса</a> (Session Initiation Protocol, SIP), как правило, транслируется через <code>WebRTC</code> и позволяет пользователям совершать телефонные звонки с помощью браузера. <a href="https://ru.wikipedia.org/wiki/RTSP" target="_blank" rel="noreferrer">Потоковый протокол реального времени</a> (Real Time Streaming Protocol, RTSP) используется в старых камерах видеонаблюдения. Они оба используют одинаковые протоколы (<code>RTP</code> и <code>SDP</code>). Мост требует добавления или удаления только тех вещей, которые специфичны для <code>WebRTC</code>.</p><h4 id="обмен-другими-данными-1" tabindex="-1">Обмен другими данными <a class="header-anchor" href="#обмен-другими-данными-1" aria-label="Permalink to “Обмен другими данными”">​</a></h4><p>Для передачи данных браузер может использовать ограниченный набор протоколов: <code>HTTP</code>, <code>WebSockets</code>, <code>WebRTC</code> и <a href="https://ru.wikipedia.org/wiki/QUIC" target="_blank" rel="noreferrer">QUIC</a>. Если мы хотим к чему-то подключиться, то должны использовать протокольный мост (protocol bridge). Протокольный мост - это сервер, который преобразует входящий трафик в нечто, доступное для браузера. Хорошим примером является <a href="https://ru.wikipedia.org/wiki/SSH" target="_blank" rel="noreferrer">SSH</a>, который используется для доступа к серверу. Каналы данных <code>WebRTC</code> в этом отношении предоставляют несколько преимуществ.</p><p>Каналы данных допускают ненадежную и неупорядоченную доставку. Это необходимо в случаях, когда критически важной является низкая задержка доставки пакетов. Мы не хотим, чтобы новые данные блокировались старыми (блокировка начала строки). Представьте, что играете в многопользовательский &quot;шутер&quot; от первого лица. Вам важно, где пользователь был две секунды назад? Если данные не прибывают вовремя, какой смысл продолжать попытки их отправки. Ненадежная и неупорядоченная доставка позволяет использовать данные сразу по их прибытии.</p><p>Каналы данных также предоставляют обратную связь о нагрузке (feedback pressure). Это позволяет своевременно определять, что мы отправляем больше данных, чем поддерживает наша сеть. В этом случае у нас есть два варианта: канал данных может помещать сообщения в буфер и доставлять их с задержкой или же мы можем игнорировать &quot;опоздавшие&quot; сообщения.</p><h4 id="телеоперация" tabindex="-1">Телеоперация <a class="header-anchor" href="#телеоперация" aria-label="Permalink to “Телеоперация”">​</a></h4><p>Телеоперация (teleoperation) - это управление удаленным устройством через каналы данных <code>WebRTC</code> и обратная отправка видео через <code>RTP</code>. Сегодня <code>WebRTC</code> позволяет разработчикам удаленно управлять автомобилями! Это используется для управления роботами при создании сайтов и доставки посылок.</p><p><code>WebRTC</code> повсюду. Все, что нужно пользователю, это браузер и устройство. Браузеры поддерживают джойстики и геймпады. <code>WebRTC</code> избавляет от необходимости устанавливать дополнительных клиентов на устройство пользователя.</p><h4 id="распределенные-cdn" tabindex="-1">Распределенные CDN <a class="header-anchor" href="#распределенные-cdn" aria-label="Permalink to “Распределенные CDN”">​</a></h4><p>Распределенные <code>CDN</code> (Content Delivery Network - сеть доставки контента) - это разновидность файлообменной сети. Распределяемые файлы настраиваются оператором <code>CDN</code>. Когда пользователь подключается к <code>CDN</code>, он может скачивать и делиться разрешенными (allowed) файлами.</p><p><code>CDN</code> хорошо работают при наличии хорошего соединения по локальной сети и отсутствии необходимости в хорошем внешнем соединении. У нас может быть один пользователь, скачавший видео, и поделившийся им с остальными. Поскольку пользователи не пытаются скачать один и тот же файл из внешней сети, передача происходит быстро.</p><h3 id="топологии-webrtc" tabindex="-1">Топологии WebRTC <a class="header-anchor" href="#топологии-webrtc" aria-label="Permalink to “Топологии WebRTC”">​</a></h3><p><code>WebRTC</code> - это протокол, предназначенный для прямого соединения двух агентов, но как разработчику подключить тысячу людей? Существует несколько способов, каждый из которых имеет свои преимущества и недостатки. Эти решения условно можно разделить на две категории: равный-к-равному (Peer-to-Peer) или клиент/сервер (Client/Server). Гибкость <code>WebRTC</code> позволяет легко реализовать любой из этих сценариев.</p><h4 id="один-к-одному" tabindex="-1">Один-к-одному <a class="header-anchor" href="#один-к-одному" aria-label="Permalink to “Один-к-одному”">​</a></h4><p>Один-к-одному (One-to-One) - первый тип подключения, используемый в <code>WebRTC</code>. Мы соединяем двух агентов напрямую и они могут обмениваться медиа и другими данными. В этом случае подключение выглядит так:</p><img src="https://habrastorage.org/webt/lo/aa/g_/loaag_qbwiyctjh1amqebgb07de.png" alt=""><br><h4 id="полная-сетка" tabindex="-1">Полная сетка <a class="header-anchor" href="#полная-сетка" aria-label="Permalink to “Полная сетка”">​</a></h4><p>Полная сетка (Full Mesh) - это решение для разработки конференции или многопользовательской игры. В данном случае каждый пользователь устанавливает соединение с другими пользователями напрямую. Это позволяет создать приложение, но имеет некоторые недостатки.</p><p>В полной сетке каждый пользователь подключается напрямую. Это означает, что нам нужно шифровать и загружать видео независимо для каждого участника сессии. Условия сети между каждым соединением будут разными, поэтому мы не может повторно использовать одно и то же видео. Обработка ошибок - в данном случае также задача не из простых. Необходимо правильно определять степень потери соединения: является ли оно полным или касается только одного удаленного пира.</p><p>По этим и другим причинам полная сетка хорошо подходит для небольших групп. Для большого количества участников сессии лучше подходит топология клиент/сервер.</p><img src="https://habrastorage.org/webt/60/zo/df/60zodfwi8kcmtlphxendcdcoubc.png" alt=""><br><h4 id="гибридная-сетка" tabindex="-1">Гибридная сетка <a class="header-anchor" href="#гибридная-сетка" aria-label="Permalink to “Гибридная сетка”">​</a></h4><p>Гибридная сетка (Hybrid Mesh) - это альтернатива полной сетки, которая может решить некоторые проблемы с ней. В гибридной сетке вместо установки соединения между каждым пользователем медиа ретранслируется через пиры в сети. Это означает, что создателю медиа не требуется большая пропускная способность для передачи данных.</p><p>Этот подход также имеет некоторые недостатки. Создатель медиа не знает о том, кому передаются данные и успешно ли они доставляются. Каждый переход также увеличивает время доставки пакетов.</p><img src="https://habrastorage.org/webt/ff/4m/7y/ff4m7y77d15seik7lux7aziqm3a.png" alt=""><br><h4 id="единица-выборочнои-пересылки" tabindex="-1">Единица выборочной пересылки <a class="header-anchor" href="#единица-выборочнои-пересылки" aria-label="Permalink to “Единица выборочной пересылки”">​</a></h4><p>Единица выборочной пересылки (Selective Forwarding Unit, SFU) также устраняет недостатки полной сетки, но несколько другим способом. <code>SFU</code> реализует топологию клиент/сервер вместо <code>P2P</code>. Каждый пир подключается к <code>SFU</code> и загружает в него свое медиа. Затем <code>SFU</code> пересылает медиа каждому подключенному клиенту.</p><p>В <code>SFU</code> каждый агент должен зашифровать и загрузить видео только один раз. Ответственность за передачу видео всем участникам ложится на <code>SFU</code>. Установка <code>SFU-соединения</code>, к тому же, проще, чем установка <code>P2P-соединения</code>. <code>SFU</code> может быть запущен на открытом маршрутизируемом адресе, что облегчает подключение к нему клиентов. Поэтому в данном случае не требуется отображение <code>NAT</code>. Однако нам все еще необходимо обеспечивать доступность <code>SFU</code> через <code>TCP</code> (через <code>ICE-TCP</code> или <code>TURN</code>).</p><p>Разработка простого <code>SFU</code> может быть завершена в течение недели. Разработка хорошего <code>SFU</code>, обрабатывающего все типы клиентов - бесконечный процесс, в который входит постоянное совершенствование контроля перегрузки, обработки ошибок и повышение производительности.</p><img src="https://habrastorage.org/webt/nq/6p/lf/nq6plfpuepd4hexwi1l7j_vhypm.png" alt=""><br><h4 id="многоточечная-конференц-система" tabindex="-1">Многоточечная конференц-система <a class="header-anchor" href="#многоточечная-конференц-система" aria-label="Permalink to “Многоточечная конференц-система”">​</a></h4><p>Многоточечная конференц-система (Multi-point Conferencing Unit, MCU) - это топология клиент/сервер, похожая на <code>SFU</code>, но объединяющая выходные потоки. Вместо того, чтобы передавать медиаданные в неизменном виде, они декодируются в один поток.</p><img src="https://habrastorage.org/webt/au/gq/3s/augq3sgbj2tvh0wtu5piwrvjh24.png" alt=""><br><h2 id="отладка" tabindex="-1">Отладка <a class="header-anchor" href="#отладка" aria-label="Permalink to “Отладка”">​</a></h2><p>Отладка <code>WebRTC</code> - сложная задача, поскольку в нем имеется большое количество подвижных частей, которые могут ломаться независимо друг от друга. Если не проявлять осторожности, можно потратить недели на решение несуществующих проблем. При обнаружении сломавшейся части, необходимо потратить еще немного времени на то, чтобы понять, почему произошла поломка.</p><h4 id="локализация-проблемы" tabindex="-1">Локализация проблемы <a class="header-anchor" href="#локализация-проблемы" aria-label="Permalink to “Локализация проблемы”">​</a></h4><p>При отладке приложения <code>WebRTC</code> сначала необходимо определить источник проблемы.</p><p><strong>Потеря сигнала</strong></p><p><strong>Потеря сети</strong></p><p>Проверяем сервер <code>STUN</code> с помощью <code>netcat</code>:</p><ol><li>Формируем 20-байтный пакет запроса на привязку (binding request packet):</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>echo -ne &quot;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&quot; | hexdump -C</span></span>
<span class="line"><span>00000000  00 01 00 00 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|</span></span>
<span class="line"><span>00000010  54 45 53 54                                       |TEST|</span></span>
<span class="line"><span>00000014</span></span></code></pre></div><p>Здесь:</p><ul><li><code>00 01</code> - тип сообщения;</li><li><code>00 00</code> - размер данных (длина соответствующего раздела);</li><li><code>21 12 a4 42</code> - магическое куки;</li><li><code>54 45 53 54 54 45 53 54 54 45 53 54</code> (декодированное в <code>ASCII</code>: <code>TESTTESTTEST</code>) - 12-байтовый идентификатор транзакции.</li></ul><ol start="2"><li>Отправляем запрос и ждем получения 32-байтного ответа:</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &quot;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&quot; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C</span></span>
<span class="line"><span>00000000  01 01 00 0c 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|</span></span>
<span class="line"><span>00000010  54 45 53 54 00 20 00 08  00 01 6f 32 7f 36 de 89  |TEST. ....o2.6..|</span></span>
<span class="line"><span>00000020</span></span></code></pre></div><p>Здесь:</p><ul><li><code>01 01</code> - тип сообщения;</li><li><code>00 0c</code> - размер данных, которые декодируются до <code>12</code> в десятичном формате;</li><li><code>21 12 a4 42</code> - магическое куки;</li><li><code>54 45 53 54 54 45 53 54 54 45 53 54</code> (декодированное в <code>ASCII</code>: <code>TESTTESTTEST</code>) - 12-байтовый идентификатор транзакции;</li><li><code>00 20 00 08 00 01 6f 32 7f 36 de 89</code> - 12-байтовые данные: <ul><li><code>00 20</code> - это тип: <code>XOR-MAPPED-ADDRESS</code>;</li><li><code>00 08</code> - размер значения, декодируемого до <code>8</code> в десятичном формате;</li><li><code>00 01 6f 32 7f 36 de 89</code> - значение данных: <ul><li><code>00 01</code> - тип адреса (<code>IPv4</code>);</li><li><code>6f 32</code> - XOR-сопоставленный (XOR-mapped) порт;</li><li><code>7f 36 de 89</code> - XOR-сопоставленный IP-адрес.</li></ul></li></ul></li></ul><p>Декодирование XOR-сопоставленного раздела является сложным, но мы можем обмануть сервер <code>STUN</code> для выполнения фиктивного отображения <code>XOR</code> с помощью фиктивного магического куки со значением <code>00 00 00 00</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &quot;\x00\x01\x00\x00\x00\x00\x00\x00TESTTESTTEST&quot; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C</span></span>
<span class="line"><span>00000000  01 01 00 0c 00 00 00 00  54 45 53 54 54 45 53 54  |........TESTTEST|</span></span>
<span class="line"><span>00000010  54 45 53 54 00 01 00 08  00 01 4e 20 5e 24 7a cb  |TEST......N ^$z.|</span></span>
<span class="line"><span>00000020</span></span></code></pre></div><p>XOR-операция против фиктивного магического куки будет идемпотентной, поэтому порт и адрес в ответе будут достоверными. Это будет работать не во всех случаях, поскольку некоторые маршрутизаторы манипулируют проходящими через них пакетами, обманывая (cheating) <code>IP-адрес</code>. Последние 8 байтов ответа будут выглядеть следующим образом:</p><ul><li><code>00 01 4e 20 5e 24 7a cb</code> - значение данных: <ul><li><code>00 01</code> - тип адреса (<code>IPv4</code>);</li><li><code>4e 20</code> - сопоставленный порт, которые декодируется до <code>20000</code> в десятичном формате;</li><li><code>5e 24 7a cb</code> - <code>IP-адрес</code>, который декодируется в <code>94.36.122.203</code>.</li></ul></li></ul><p><strong>Ошибка безопасности</strong></p><p><strong>Ошибка медиа</strong></p><p><strong>Ошибка данных</strong></p><h4 id="инструменты-для-отладки" tabindex="-1">Инструменты для отладки <a class="header-anchor" href="#инструменты-для-отладки" aria-label="Permalink to “Инструменты для отладки”">​</a></h4><p><strong>netcat (nc)</strong></p><p><a href="https://ru.wikipedia.org/wiki/Netcat" target="_blank" rel="noreferrer">netcat</a> - сетевая утилита командной строки для чтения из/записи в сетевые соединения с помощью <code>TCP</code> или <code>UDP</code>. Данная утилита, обычно, доступна через команду <code>nc</code>.</p><p><strong>tcpdump</strong></p><p><a href="https://ru.wikipedia.org/wiki/Tcpdump" target="_blank" rel="noreferrer">tcpdump</a> - это интерфейс командной строки для анализа сетевых пакетов с данными.</p><p>Наиболее распространенные команды:</p><ul><li>перехватываем пакеты <code>UDP</code> в/из порта <code>19302</code>, отображаем шестнадцатеричный дамп (hexdump) содержимого пакета</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo tcpdump &#39;udp port 19302&#39; -xx</span></span></code></pre></div><ul><li>то же самое, но сохраняем пакеты в файле <code>PCAP</code> (захват пакета - packet capture) для дальнейшего изучения</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo tcpdump &#39;udp port 19302&#39; -w stun.pcap</span></span></code></pre></div><p>Файл <code>PCAP</code> можно открыть с помощью команды <code>wireshark stun.pcap</code>.</p><p><strong>Wireshark</strong></p><p><a href="https://www.wireshark.org/" target="_blank" rel="noreferrer">Wireshark</a> - это широко используемый анализатор сетевых протоколов.</p><p><strong>webrtc-internals</strong></p><p><code>Chrome</code> предоставляет встроенную страницу статистики <code>WebRTC</code>: <code>chrome://webrtc-internals</code>.</p><h3 id="задержка" tabindex="-1">Задержка <a class="header-anchor" href="#задержка" aria-label="Permalink to “Задержка”">​</a></h3><p>Как понять, что имеет место высокая задержка доставки сообщений? Мы можем заметить, что наше видео <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B3_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B9_%D1%81%D0%BB%D0%B5%D0%BD%D0%B3)" target="_blank" rel="noreferrer">лагает</a> (lagging), но как определить точную величину задержки? Для уменьшения задержки, необходимо сначала ее измерить.</p><p>Предполагается, что истинная задержка должна измеряться от начала до конца (end-to-end). Это означает учет не только задержки сетевого пути между отправителем и получателем, но общую задержку захвата камеры, шифрования кадров, передачи, получения, расшифровки и отображения, а также возможную буферизацию (постановку задач в очередь - queueing) на любом из этапов.</p><p>Задержка от начала до конца - это не просто сумма задержек каждого компонента.</p><p>Несмотря на то, что теоретически мы можем измерить задержку каждого компонента потоковой передачи видео по отдельности и суммировать результаты, на практике некоторые компоненты будут либо недоступными для измерения, либо результаты измерения этих компонентов вне конвейера (pipeline) будут сильно отличаться от результатов их измерения в связке с другими компонентами. Разная глубина очереди на разных этапах, топология сети и изменения экспозиции камеры - вот лишь несколько примеров влияния компонентов на конечную задержку.</p><p>Задержка каждого компонента в системе потоковой передачи данных может меняться и влиять на нижележащие компоненты. Даже содержимое захваченного видео влияет на задержку. Например, требуется намного больше битов для высокочастотных (high frequency) изображений вроде ветвей дерева по сравнению с низкочастотными кадрами вроде чистого голубого неба. Камера с автоматической экспозицией может захватывать кадр гораздо дольше ожидаемых <code>33 мс</code>, даже при установке частоты захвата (capture rate) в значение <code>30 кадров в секунду</code> (frames per second). Передача по сети, особенно по сотовой, также очень динамична из-за постоянно меняющегося спроса (на ресурсы сети). Чем больше пользователей, тем больше &quot;шума&quot; в эфире. Наша физическая локация (например, в зоне с плохим сигналом) и множество других факторов увеличивают потерю пакетов и задержку. Что происходит при отправке пакета по сети, например, через адаптер <code>WiFi</code> или <code>LTE-модем</code>? Если пакет не может быть доставлен незамедлительно, он помещается в очередь, чем больше очередь, тем выше задержка.</p><h4 id="ручное-измерение-конечнои-задержки" tabindex="-1">Ручное измерение конечной задержки <a class="header-anchor" href="#ручное-измерение-конечнои-задержки" aria-label="Permalink to “Ручное измерение конечной задержки”">​</a></h4><p>Когда мы говорим о конечной задержке, мы имеем в виду время между возникновением события и его наблюдением, например, отображением видеокадра на экране.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EndToEndLatency = T(observe) - T(happen)</span></span></code></pre></div><p>Наивный подход заключается в фиксировании времени возникновения события и его вычитание из времени наблюдения события. Однако при точности в <code>мс</code> критически важной становится задача синхронизации времени. Попытки синхронизации времени в распределенных системах являются практически бесполезными, поскольку даже небольшая ошибка приводит к недостоверному измерению задержки.</p><p>Простейшим решением проблемы синхронизации часов является использование одних часов. Для этого отправитель и получатель должны находиться в одной системе отсчета.</p><p>Представим, что у нас есть таймер, отсчитывающий миллисекунды. Мы хотим измерить задержку в системе, в которой наш таймер транслируется в реальном времени на удаленный экран. Наивный способ измерения времени между возникновением события и появлением на экране видео кадра состоит в следующем:</p><ul><li>фиксируем время на часах;</li><li>отправляем видео получателю, находящемуся в той же физической локации;</li><li>фиксируем время появления видео на экране получателя;</li><li>вычитаем одно время из другого.</li></ul><p>Это самый простой способ измерения конечной задержки. Он учитывает все компоненты, влияющие на задержку (камера, кодировщик, сеть, декодер) и не полагается на синхронизацию часов.</p><img src="https://habrastorage.org/webt/pm/gp/53/pmgp53n6vkxzs0avbxnrzgrudms.png" alt=""><br><img src="https://habrastorage.org/webt/sp/z8/dm/spz8dm-ss7f2lfwaky2krrn-79i.png" alt=""><br><p>На приведенном выше фото конечная задержка составляет 101 мс. Время возникновения события составляет <code>10:16:02.761</code>, а время его наблюдения - <code>10:16:02.862</code>.</p><h4 id="автоматическое-измерение-задержки" tabindex="-1">Автоматическое измерение задержки <a class="header-anchor" href="#автоматическое-измерение-задержки" aria-label="Permalink to “Автоматическое измерение задержки”">​</a></h4><p>В настоящее время (май 2021 года) стандарт <code>WebRTC</code>, посвященный конечной задержке, находится в стадии <a href="https://github.com/w3c/webrtc-stats/issues/537" target="_blank" rel="noreferrer">активного обсуждения</a>. <code>Firefox</code> реализовал набор <code>API</code> поверх стандартных <code>API</code> <code>WebRTC</code> для автоматического измерения задержки. Однако далее мы рассмотрим более общий способ.</p><img src="https://habrastorage.org/webt/my/nx/pl/mynxpl_zzvxkgzxiughg4ncbffa.png" alt=""><br><p>Суть времени пути (round-trip time, rtt): я отправляю тебе мое время <code>tR1</code>, при получении от тебя <code>tR1</code> обратно я фиксирую время <code>tR2</code>, таким образом, время пути составляет <code>tR1 - tR2</code>.</p><p>При наличии канала коммуникации между отправителем и получателем (например, <code>DataChannel</code>), получатель может смоделировать монотонные часы (monotonic clock) отправителя следующим образом:</p><ol><li>Получатель отправляет сообщение со своим временем <code>tR1</code>.</li><li>При получении сообщения от получателя, отправитель фиксирует свое время <code>tS1</code> и отправляет копию <code>tR1</code> и <code>tS1</code>, а также время видеотрека отправителя <code>tSV1</code>.</li><li>При получении сообщений от отправителя, получатель фиксирует свое время <code>tR2</code> и вычисляет время пути: <code>RTT = tR2 - tR1</code>.</li><li>Времени пути <code>RTT</code> и времени отправителя <code>tS1</code> достаточно для вычисления монотонных часов отправителя. Текущее время отправителя для <code>tR2</code> будет равняться <code>tS1</code> + половина времени пути.</li><li>Времени отправителя <code>tS1</code> вместе с временем видеотрека <code>tSV1</code> достаточно для синхронизации времени видеотрека получателя со временем видеотрека отправителя.</li></ol><p>Поскольку нам известно время <code>tSV1</code>, мы можем приблизительно вычислить задержку посредством вычитания текущего времени отображения видеокадра (<code>actual_video_time</code>) из ожидаемого времени:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>expected_video_time = tSV1 + time_since(tSV1)</span></span>
<span class="line"><span>latency = expected_video_time - actual_video_time</span></span></code></pre></div><p>Недостатком этого метода является то, что не учитывается задержка камеры. В большинстве видеосистем время захвата кадра считается временем доставки кадра из камеры в память, что происходит через некоторое время после возникновения события записи.</p><p><strong>Пример вычисления задержки</strong></p><p>В следующем примере мы открываем канал данных <code>latency</code> на стороне получателя и периодически отправляем время монотонного таймера отправителю. Отправитель отвечает сообщением в формате <code>JSON</code>, и получатель вычисляет задержку на основании этого сообщения.</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;received_time&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64714</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Время, отправленное получателем, которое фиксируется отправителем</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;delay_since_received&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">46</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Время, прошедшее с последнего `received_time`, полученного отправителем</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;local_clock&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1597366470336</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Текущее монотонное время отправителя</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;track_times_msec&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;myvideo_track1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            13100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Временная метка видеокадра RTP (в мс)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            1597366470289</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Временная метка монотонных часов видеокадра</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Открываем канал данных на стороне получателя:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dataChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> peerConnection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createDataChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;latency&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Периодически отправляем время получателя <code>tR1</code>. В данном случае интервал составляет <code>2 секунды</code>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tR1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dataChannel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tR1))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Обрабатываем сообщение получателя на стороне отправителя:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// предположим, что `event.data` - это строка типа &#39;1234567&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tR1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> now</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tSV1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Временная метка текущего фрейма RTP, преобразованная в мс</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tS1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1597366470289</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Временная метка монотонных часов текущего фрейма</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> msg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;received_time&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: tR1,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;delay_since_received&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;local_clock&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: now,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;track_times_msec&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;myvideo_track1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [tSV1, tS1]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dataChannel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg))</span></span></code></pre></div><p>Обрабатываем сообщение отправителя на стороне получателя, вычисляем задержку и выводим ее в консоль:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tR2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fromSender</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tR1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fromSender[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> delay</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fromSender[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Сколько прошло времени между получением сообщения отправителем и отправкой ответа</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> senderTimeFromResponse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fromSender[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rtt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tR2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delay </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tR1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> networkLatency</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rtt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> senderTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (senderTimeFromResponse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delay </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> networkLatency)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> video$</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;video&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video$.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestVideoFrameCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">framemeta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Вычисляем текущее время отправителя</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> delaySinceVideoCallbackRequested</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tR2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  senderTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delaySinceVideoCallbackRequested</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tSV1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tS1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fromSender[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> timeSinceLastKnownFrame</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> senderTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tS1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> expectedVideoTimeMsec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tSV1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeSinceLastKnownFrame</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> actualVideoTimeMsec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(framemeta.rtpTimestamp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 90</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Преобразуем время RTP (90000) в мс</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> latency</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expectedVideoTimeMsec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> actualVideoTimeMsec</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;latency&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, latency, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ms&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p><strong>Реальное время видео в браузере</strong></p><p><code>HTMLVideoElement.requestVideoFrameCallback()</code> позволяет разработчикам получать уведомления о представлении фрейма для композиции.</p><p>До недавнего времени (май 2020 года) было практически невозможно получить достоверное время отображения видеокадра в браузере. Данная проблема решалась через <code>HTMLVideoElement.currentTime</code>, но не давала необходимой точности. В настоящее время стандарт <code>W3C</code> <a href="https://wicg.github.io/video-rvfc/" target="_blank" rel="noreferrer">HTMLVideoElement.requestVideoFrameCallback()</a>, позволяющий получать текущее время видеокадра, поддерживается <code>Chrome</code> и <code>Firefox</code>. Несмотря на то, что это дополнение кажется тривиальным, оно сделало возможным использование некоторых продвинутых возможностей в приложениях, требующих синхронизации аудио и видео. Функция обратного вызова включает поле <code>rtpTimestamp</code> - временную метку <code>RTP</code>, связанную с текущим видеокадром.</p><h4 id="отладка-задержки" tabindex="-1">Отладка задержки <a class="header-anchor" href="#отладка-задержки" aria-label="Permalink to “Отладка задержки”">​</a></h4><p>Поскольку отладка в данном случае означает измерение задержки, общее правило таково: упрощаем настройку до минимума при условии сохранения (воспроизводимости) проблемы. Чем больше компонентов мы удалим, тем проще будет определить, какой компонент вызывает задержку.</p><p><strong>Задержка камеры</strong></p><p>В зависимости от настроек камеры производимая ей задержка может быть разной. Проверяем настройки автоэкспозиции, автофокуса и автоматического баланса белого. Всем автоматическим настройкам требуется дополнительное время для анализа захваченного изображения перед его передачей в стек <code>WebRTC</code>.</p><p>Если у вас <code>Linux</code>, для управления настройками камеры можно воспользоваться командой <code>v4l2-ctl</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## Отключаем автофокус</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v4l2-ctl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/video0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> focus_auto=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## Устанавливаем фокус в значение бесконечности</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v4l2-ctl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/video0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> focus_absolute=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span></code></pre></div><p>Также можно воспользоваться графическим интерфейсом <code>guvcview</code> для быстрой проверки и установки настроек камеры.</p><p><strong>Задержка шифрования</strong></p><p>Большинство современных кодировщиков буферизуют некоторые кадры перед их шифрованием. Их главный приоритет - баланс между качеством производимого изображения и битрейтом. Многопроходное кодирование (multipass encoding) - экстремальный пример пренебрежения кодировщиком конечной задержкой. На первом проходе кодировщик &quot;проглатывает&quot; видео целиком перед началом производства кадров.</p><p>Однако при правильной настройке можно добиться уменьшения подкадровой (sub-frame) задержки. Убедитесь, что ваш кодировщик не использует чрезмерное количество эталонных кадров (reference frames) и не полагается на B-кадры (B-frames). Настройки для разных кодеков будет разными, но для <code>x264</code> рекомендуется использовать <code>tune=zerolatency</code> и <code>profile=baseline</code> для снижения задержки.</p><p><strong>Сетевая задержка</strong></p><p>Сетевая задержка - это то, с чем почти ничего нельзя сделать, кроме обновления сети. Сетевая задержка - это как погода: мы не можем остановить дождь, но можем посмотреть прогноз и взять с собой зонт. <code>WebRTC</code> измеряет сетевые условия с точностью до мс. И при этом самые важные метрики:</p><ul><li>время пути;</li><li>потеря и ретрансляция пакетов.</li></ul><p><strong>Время пути</strong></p><p>Стек <code>WebRTC</code> имеет встроенный <a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime" target="_blank" rel="noreferrer">механизм для измерения сетевого времени пути (RTT)</a>. Достаточно хорошее приблизительное вычисление задержки - это половина <code>RTT</code>. Механизм исходит из предположения, что отправка и получение пакетов занимает одинаковое время, что не всегда соответствует действительности. <code>RTT</code> устанавливает нижнюю границу конечной задержки. Наши видеокадры не могут достичь получателя быстрее, чем за <code>RTT / 2</code>, независимо от того, насколько оптимизирована наша камера и конвейер кодировщика.</p><p>Встроенный механизм <code>RTT</code> основан на специальных пакетах <code>RTCP</code>, которые называются отчетами отправителя/получателя (sender/receiver reports). Отправитель передает свое время получателю, получатель отвечает тем же временем. Это позволяет отправителю определить количество времени, которое занимает путь пакета туда и обратно.</p><p><strong>Потеря и ретрансляция пакетов</strong></p><p>Протоколы <code>RTP</code> и <code>RTCP</code> основаны на <code>UDP</code>, что означает отсутствие гарантии сохранения порядка, надежной доставки пакетов или отсутствия дубликатов. Все это может происходить и действительно происходит в реальных <code>WebRTC-приложениях</code>. Простые реализации декодеров ожидают получения всех кадров изображения для его успешного восстановления. В случае потери пакетов P-кадра (P-frame) могут появиться различные артефакты декодирования. Если потеряны пакеты I-кадра (I-frame), все зависимые кадры получат тяжелые артефакты или совсем не будут декодированы. Это может привести к &quot;зависанию&quot; видео на какое-то время.</p><p>Для преодоления зависания видео или появления артефактов декодирования <code>WebRTC</code> использует сообщения с негативными благодарностями (Negative Acknowledgement, NACK). Когда получатель не получает ожидаемый пакет <code>RTP</code>, он возвращает отправителю сообщение <code>NACK</code> для повторной отправки недостающего пакета. Получатель ждет повторной отправки пакета. Такое ожидание увеличивает задержку. Количество отправленных и полученных пакетов <code>NACK</code> записывается в статические поля <a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcoutboundrtpstreamstats-nackcount" target="_blank" rel="noreferrer">nackCount</a> исходящего потока и <a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-nackcount" target="_blank" rel="noreferrer">nackCount</a> входящего потока.</p><p>Графы входящих и исходящих <code>nackCount</code> можно увидеть на странице <code>webrtc-internals</code>. Если мы видим, что <code>nackCount</code> увеличивается, значит, имеет место высокая потеря пакетов, и стек <code>WebRTC</code> делает все возможное для плавного воспроизведения видео или аудио.</p><p>При высокой потере пакетов, когда декодер не может произвести изображение или последующие зависимые изображения, например, при полной потере I-кадра, последующие P-кадры не декодируются. Получатель пытается смягчить это путем отправки специального сообщения-индикатора потери изображения (Picture Loss Indicator, PLI). Когда отправитель получает <code>PLI</code>, он повторно отправляет новый I-кадр. I-кадры, как правило, больше P-кадров по размеру. Это увеличивает количество пакетов для передачи. Как и в случае с <code>NACK</code>, получатель ждет получения нового I-кадра, что приводит к увеличению задержки.</p><p>Смотрите на значение поля <code>pliCount</code> на странице <code>webrtc-internals</code>. Если значение данного поля увеличивается, установите меньшее количество производимых декодером кадров или включите более лояльный к ошибкам режим.</p><p><strong>Задержка на стороне получателя</strong></p><p>Задержка также увеличивается при прибытии пакетов в неправильном порядке. Если нижняя часть изображения прибывает раньше верхней, декодирование изображения будет заниматься чуть больше времени, чем когда части изображения прибывают в правильном порядке. Мы говорили об этом в разделе, посвященном джиттеру.</p><p>Встроенная метрика <a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferdelay" target="_blank" rel="noreferrer">jitterBufferDelay</a> показывает, как долго кадр находился в буфере получателя, ожидая прибытия недостающих пакетов, перед его передачей декодеру для расшифровки.</p></div></div></main><footer class="VPDocFooter" data-v-ee010771 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><!----></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/vitepress/basics_js/array_methods.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>Методы массивов</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"basics_js_array_methods.md\":\"C_SrF9V9\",\"basics_js_arrays.md\":\"uswzxJsQ\",\"basics_js_async.md\":\"D1XiQt52\",\"basics_js_design_patterns.md\":\"CijNVODe\",\"basics_js_design_principles.md\":\"CKp5TrlR\",\"basics_js_dom.md\":\"B24dNXRf\",\"basics_js_event_loop.md\":\"BH7juzJ1\",\"basics_js_events.md\":\"DhDyfGsK\",\"basics_js_functions.md\":\"BedUbGrR\",\"basics_js_map.md\":\"rrHWqQiw\",\"basics_js_modules.md\":\"CKOT1dKA\",\"basics_js_numbers.md\":\"Em0tQyFl\",\"basics_js_object_methods.md\":\"sN7-Frq4\",\"basics_js_objects.md\":\"CUPumwXs\",\"basics_js_promises.md\":\"nvsAgQdb\",\"basics_js_questions_1.md\":\"CTS_IkJx\",\"basics_js_set.md\":\"B24ZJlnx\",\"basics_js_solid.md\":\"DSBqO5FZ\",\"basics_js_strings.md\":\"D_xkL_Nn\",\"basics_js_wcag.md\":\"DOyErbfw\",\"basics_vue_components.md\":\"BgUwuJZI\",\"basics_vue_composables.md\":\"BVu12-H7\",\"basics_vue_composition-api.md\":\"-6n_OYak\",\"basics_vue_definemodel.md\":\"Dur-JFVV\",\"basics_vue_lifecycle_hooks.md\":\"CjXV8D8P\",\"basics_vue_reactivity.md\":\"B6segfIX\",\"basics_vue_script-setup.md\":\"BVOc35hm\",\"basics_vue_suspense.md\":\"D_hG54b3\",\"basics_vue_templaterefs.md\":\"C8-SSmnN\",\"basics_vue_watcheffect.md\":\"BQANoMmB\",\"cheatsheet_axios.md\":\"2eSWVD0N\",\"cheatsheet_cors.md\":\"CqpLfj1_\",\"cheatsheet_create-react-app.md\":\"B8d-YHmH\",\"cheatsheet_custom-components.md\":\"5-5QJm6l\",\"cheatsheet_custom-hooks.md\":\"BxpygcMn\",\"cheatsheet_devops.md\":\"BtzcGZ_6\",\"cheatsheet_express-api.md\":\"BbdebzLR\",\"cheatsheet_fs.md\":\"BxUBaBrI\",\"cheatsheet_helmet.md\":\"CWj0cVBq\",\"cheatsheet_html5.md\":\"BwACO0aX\",\"cheatsheet_intl_index.md\":\"BSN_e9zy\",\"cheatsheet_intro.md\":\"DqxDwmZh\",\"cheatsheet_js-dom.md\":\"BRgGip2s\",\"cheatsheet_json-server_index.md\":\"DlAnF-4r\",\"cheatsheet_jsonwebtoken.md\":\"C7zNKeSJ\",\"cheatsheet_markdown.md\":\"Abliq_FB\",\"cheatsheet_mastering-ts.md\":\"B5yBv9mS\",\"cheatsheet_netlify.md\":\"CCITyAxy\",\"cheatsheet_react-hooks.md\":\"D3PlFpAh\",\"cheatsheet_react-types.md\":\"wwlaYUo5\",\"cheatsheet_react-typescript.md\":\"EEjxh5r9\",\"cheatsheet_regexp_index.md\":\"DrBZ6wA_\",\"cheatsheet_rust.md\":\"B8MvuHW2\",\"cheatsheet_security-headers_index.md\":\"Cx4Y2700\",\"cheatsheet_sql.md\":\"BfAHV6Sw\",\"cheatsheet_styled-components.md\":\"BAXou2Q1\",\"cheatsheet_system-design-101.md\":\"979hFU5o\",\"cheatsheet_temporal.md\":\"K5Zslnof\",\"cheatsheet_ts-design-patterns.md\":\"Blnwppkg\",\"cheatsheet_ts.md\":\"DYWMF1Pu\",\"cheatsheet_vite.md\":\"DlqJzOg0\",\"cheatsheet_web-accessibility_index.md\":\"BvV_EDzN\",\"cheatsheet_web-media.md\":\"WFwCZK-n\",\"cheatsheet_web-speech.md\":\"ezqQqCSX\",\"cheatsheet_webpack.md\":\"BKHDriPV\",\"cheatsheet_zustand.md\":\"DstVc7nY\",\"guide_apollo_client.md\":\"DdHiOnSP\",\"guide_apollo_server.md\":\"Cdjg4fOx\",\"guide_convex.md\":\"DeQoBosk\",\"guide_docker.md\":\"BkQzcu_i\",\"guide_graphql.md\":\"CCajO-YQ\",\"guide_guide.md\":\"B3dDVGNI\",\"guide_intro.md\":\"BPCtEM0o\",\"guide_mongoose.md\":\"ag91eXxL\",\"guide_nextjs-tutorial.md\":\"BYktUWni\",\"guide_nextjs.md\":\"CD4iccwN\",\"guide_prisma.md\":\"Dg70BzMM\",\"guide_react-query.md\":\"FldfI3HN\",\"guide_react-router.md\":\"xqya1DDz\",\"guide_react-spring.md\":\"CrwyyZbX\",\"guide_react-transition-group.md\":\"on7IqPbH\",\"guide_recoil.md\":\"Dn10Ju-I\",\"guide_redux-toolkit.md\":\"xonJuNqG\",\"guide_remix.md\":\"Dwd02LW9\",\"guide_rust-cookbook.md\":\"CqGB5eOT\",\"guide_rust.md\":\"CCUD060e\",\"guide_sequelize.md\":\"Bl51-91h\",\"guide_shorelark.md\":\"DH0m97FH\",\"guide_socket_index.md\":\"I3Tw1PVz\",\"guide_supabase.md\":\"ijVp9nhe\",\"guide_tokio.md\":\"BB62A-zw\",\"guide_trpc.md\":\"Ciy1oCb4\",\"guide_ts.md\":\"BfWxvgV7\",\"guide_wb_index.md\":\"DXs1wTUl\",\"guide_web-streams.md\":\"DMl51Mjp\",\"guide_webrtc.md\":\"Cbn-xxww\",\"index.md\":\"C5aILZnJ\",\"links.md\":\"-YURgcP9\",\"links_index.md\":\"BjESoxdJ\",\"markdown-examples.md\":\"CaeQujCa\",\"other_best-practices.md\":\"Brd036yA\",\"other_gitconfig.md\":\"WNAUEoyy\",\"other_gitignore.md\":\"aKMQQ73k\",\"other_index.md\":\"DWmSbE4y\",\"other_intro.md\":\"CZXI7FGU\",\"other_js-data-structures.md\":\"CP-DrrgW\",\"other_js-questions.md\":\"Bs75depI\",\"other_js-questions2.md\":\"BCLYTrGu\",\"other_react-philosophies.md\":\"C92vTMwK\",\"other_react-questions.md\":\"DMIZguQV\",\"other_snippets-css.md\":\"C-grpRAS\",\"other_snippets-js.md\":\"Cxbq-YUl\",\"other_snippets-js2.md\":\"BAx_PGWU\",\"other_snippets-node_snippets-node.md\":\"Bv07M606\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Шпаргалки по IT\",\"description\":\"Just playing around\",\"base\":\"/vitepress/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Шпаргалки\",\"link\":\"/markdown-examples\"},{\"text\":\"Ссылки\",\"link\":\"/links\"},{\"text\":\"Разное\",\"link\":\"/other/\"},{\"text\":\"Руководства\",\"link\":\"/guide/guide\"}],\"sidebar\":[{\"text\":\"База JS\",\"collapsible\":true,\"collapsed\":true,\"sidebarKey\":\"group1\",\"items\":[{\"text\":\"Массивы\",\"collapsible\":true,\"collapsed\":true,\"items\":[{\"text\":\"Методы массивов\",\"link\":\"/basics_js/array_methods\"},{\"text\":\"Массивы\",\"link\":\"/basics_js/arrays\"}]},{\"text\":\"Объекты\",\"collapsible\":true,\"collapsed\":true,\"items\":[{\"text\":\"Методы объектов\",\"link\":\"/basics_js/object_methods\"},{\"text\":\"Объекты\",\"link\":\"/basics_js/objects\"}]},{\"text\":\"Асинхронное программирование\",\"collapsible\":true,\"collapsed\":true,\"items\":[{\"text\":\"База\",\"link\":\"/basics_js/async\"},{\"text\":\"Промисы\",\"link\":\"/basics_js/promises\"}]},{\"text\":\"Event Loop\",\"link\":\"/basics_js/event_loop\"},{\"text\":\"Design patterns\",\"link\":\"/basics_js/design_patterns\"},{\"text\":\"Design principles\",\"link\":\"/basics_js/design_principles\"},{\"text\":\"Dom\",\"link\":\"/basics_js/dom\"},{\"text\":\"Events\",\"link\":\"/basics_js/events\"},{\"text\":\"Functions\",\"link\":\"/basics_js/functions\"},{\"text\":\"Map\",\"link\":\"/basics_js/map\"},{\"text\":\"Set\",\"link\":\"/basics_js/set\"},{\"text\":\"Modules\",\"link\":\"/basics_js/modules\"},{\"text\":\"Numbers\",\"link\":\"/basics_js/numbers\"},{\"text\":\"Strings\",\"link\":\"/basics_js/strings\"},{\"text\":\"Часто задаваемые вопросы\",\"link\":\"/basics_js/questions_1\"},{\"text\":\"Основные принципы ООП\",\"link\":\"/basics_js/solid\"},{\"text\":\"WCAG\",\"link\":\"/basics_js/WCAG\"}]},{\"text\":\"База Vue\",\"collapsible\":true,\"collapsed\":true,\"sidebarKey\":\"group2\",\"items\":[{\"text\":\"Components\",\"link\":\"/basics_vue/components\"},{\"text\":\"Composables\",\"link\":\"/basics_vue/composables\"},{\"text\":\"Composition Api\",\"link\":\"/basics_vue/composition-api\"},{\"text\":\"Lifecycle Hooks\",\"link\":\"/basics_vue/lifecycle_hooks\"},{\"text\":\"Реактивность\",\"link\":\"/basics_vue/reactivity\"},{\"text\":\"Script Setup\",\"link\":\"/basics_vue/script-setup\"},{\"text\":\"Suspense\",\"link\":\"/basics_vue/suspense\"},{\"text\":\"defineModel\",\"link\":\"/basics_vue/defineModel\"},{\"text\":\"Template Refs\",\"link\":\"/basics_vue/templateRefs\"},{\"text\":\"Watch Effect\",\"link\":\"/basics_vue/watchEffect\"}]},{\"text\":\"Руководства\",\"link\":\"/guide/guide\"},{\"text\":\"Разное\",\"link\":\"/other/\"},{\"text\":\"Ссылки\",\"link\":\"/links/\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/AlexeyZelenko/vitepress\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>